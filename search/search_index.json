{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u2602\ufe0f BoCoEL","text":""},{"location":"#bayesian-optimization-as-a-coverage-tool-for-evaluating-large-language-models","title":"Bayesian Optimization as a Coverage Tool for Evaluating Large Language Models","text":""},{"location":"#why-bocoel","title":"\ud83e\udd14 Why BoCoEL?","text":"<p>Large language models are expensive and slow behemoths, and evaluating them on gigantic modern datasets only makes it worse. </p> <p>If only there is a way to just select a meaningful (and small) subset of the corpus and obtain a highly accurate evaluation.....</p> <p>Wait, sounds like Bayesian Optimization!</p> <p>Bocoel works in the following steps:</p> <ol> <li>Encode individual entry into embeddings (way cheaper / faster than LLM and reusable).</li> <li>Use Bayesian optimization to select queries to evaluate.</li> <li>Use the queries to retrieve from our corpus (with the encoded embeddings).</li> <li>Profit.</li> </ol> <p>The evaluations generated are easily managed by the provided manager utility.</p> <p>To our knowledge, this is the first work aiming to reduce computation costs during evaluation (benchmarking) with a (possibly dynamic) budget.</p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83c\udfaf Accurately evaluate large language models with just tens of samples from your selected corpus.</li> <li>\ud83d\udc82\u200d\u2642\ufe0f Uses the power of Bayesian optimization to select an optimal subset of samples for language model to evaluate.</li> <li>\ud83d\udcaf Evalutes the corpus on the model in addition to evaluating the model on corpus.</li> <li>\ud83e\udd17 Support for <code>GPT2</code>, <code>Pythia</code>, <code>LLAMA</code> and more through integration with huggingface transformers and datasets</li> <li>\ud83e\udde9 Modular design.</li> <li>\ud83d\udd0e Efficient representation of the corpus / dataset such as N-sphere representation or whitening of the latent space to agument evaluation quality.</li> </ul>"},{"location":"#give-us-a-star","title":"\u2b50 Give us a star!","text":"<p>Like what you see? Please consider giving this a star (\u2605)!</p>"},{"location":"#bayesian-optimization","title":"\u267e\ufe0f Bayesian Optimization","text":"<p>Simply put, Bayesian optimization aims to optimize either the exploration objective (the purple area in the image) or the exploitation object (the height of the black dots). It uses Gaussian processes as a backbone for inference, and uses an acquisition function to decide where to sample next. See here for an a more in-depth introduction.</p> <p>Since Bayesian optimization works well with expensive-to-evaluate black-box model (paraphrase: LLM), it is perfect for this particular use case. Bocoel uses Bayesian optimization as a backbone for exploring the embedding space given by our corpus, which allows it to select a good subset acting as a mini snapshot of the corpus.</p>"},{"location":"#performance-implications","title":"\ud83c\udfce\ufe0f Performance Implications","text":"<p>LLMs are painfully slow, especially generative ones (which is what is usually referred to as LLM), since sequence generation is sequential by nature.</p> <p>Despite <code>bocoel</code>'s requirement to use an embedder to encode the entire corpus, embedders are faster than LLMs by orders of magnitude and the time is gained back by practically any savings in evaluating LLMs.</p>"},{"location":"#installation","title":"\u2b07\ufe0f Installation","text":"<p>I don't want optional dependencies:</p> <pre><code>pip install bocoel\n</code></pre> <p>Give me the full experience (all optional dependencies):</p> <pre><code>pip install \"bocoel[all]\"\n</code></pre>"},{"location":"#usage","title":"\ud83d\udd2c Usage","text":"<p>See the folder examples/getting_started for a simplistic usage of the library to get started with just a few lines of code.</p>"},{"location":"#develop-with-bocoel","title":"\u270d\ufe0f Develop with BoCoEL","text":"<p>Usage examples are under the folder <code>examples</code>. API reference can be found here.</p>"},{"location":"#contributing","title":"\ud83e\udd70 Contributing","text":"<p>Contributors wanted! Don't be shy. Feel free to file issues and PRs. For PRs, please follow the guide on contributing and the code of conduct. Openness and inclusiveness are taken very seriously.</p>"},{"location":"#roadmap-work-in-progress","title":"\ud83d\uddfa\ufe0f Roadmap: work in progress","text":"<ul> <li>\ud83e\ude91 Simpler usage. I should provide a high level wrapper for the entire library s.t. evaluations can be run in one line.</li> <li>\ud83d\udcca Visualization module of the evaluation.</li> <li>\ud83c\udfb2 Integration of alternative methods (random, kmedoids...) with Gaussian process.</li> <li>\ud83e\udd68 Integration with more backends such as VLLM and OpenAI's API.</li> <li>\ud83c\udd95 Support for Python 3.11+</li> </ul>"},{"location":"#license-and-citation","title":"\ud83c\udff7\ufe0f License and Citation","text":"<p>The code is available under Apache License.</p> <p>If you find this project helpful in your research, please cite this work at</p> <pre><code>@misc{bocoel2024,\n    title = {BoCoEL: Bayesian Optimization as a Coverage Tool for Evaluating Large Language Models},\n    url = {https://rentruewang.github.io/bocoel/research/},\n    author = {Wang, RenChu},\n    month = {January},\n    year = {2024}\n}\n</code></pre>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Instead of evaluating with queries (vectors), evaluate with locations (integers) in the corpus. AxServiceOptimizer is responsible for performing retrieval.</li> </ul>"},{"location":"CHANGELOG/#v010-2024-02-12","title":"v0.1.0 - 2024-02-12","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Factory methods.</li> <li>Metrics to gain insights to how well the model and the corpus are performing.</li> <li>Getting started guide.</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Organization of ensemble experiments. Added scripts for collection and visualization.</li> <li>Miscellaneous bug fix and documentation.</li> </ul>"},{"location":"CHANGELOG/#v004-2024-02-05","title":"v0.0.4 - 2024-02-05","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Glue dataset.</li> <li>Support for embedding multiple columns in the storage.</li> <li>Manager and Exam utility.</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Split language models abstractions into generative and classifiers.</li> <li>Storage now supports retriving slices and list of indices.</li> </ul>"},{"location":"CHANGELOG/#v003-2024-01-24","title":"v0.0.3 - 2024-01-24","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Website added.</li> <li>LanguageModels support prediction via logits.</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Optimizers uses a generator like interface.</li> </ul>"},{"location":"CHANGELOG/#v002-2024-01-20","title":"v0.0.2 - 2024-01-20","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Decoupling of state into different components.</li> <li>Evaluators renamed to Adaptors.</li> </ul>"},{"location":"CHANGELOG/#v001-2024-01-18","title":"v0.0.1 - 2024-01-18","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Auto release to PyPI.</li> <li>A few implementations for baselines.</li> </ul>"},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Index now support batch size != 1 and k != 1.</li> <li>Batch size mandatary for Index, Embedders, LanguageModel, and Optimizer.</li> <li>Visualization change.</li> </ul>"},{"location":"CHANGELOG/#v000-2024-01-10","title":"v0.0.0 - 2024-01-10","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Index - Faiss, Hnswlib, Polar, Whitening.</li> <li>Storage - Pandas, Datasets</li> <li>Embedders - SentenceTransformers</li> <li>Corpus - Composed</li> <li>LanguageModel - Huggingface</li> <li>Scores - BLEU (NLTK, SacreBLEU), Rouge (Rouge, RougeScore), Exact</li> <li>Adaptor - BigBench</li> <li>Optimizer - Ax / BoTorch, KMeans</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>The goal here is to make contributing to <code>bocoel</code> as painless as possible.</p> <p>Feel free to reach out and I'll try to respond as soon as possible!</p>"},{"location":"CONTRIBUTING/#development-installation","title":"Development installation","text":"<p>First, clone and navigate into the project:</p> <pre><code>git clone https://github.com/rentruewang/bocoel\ncd bocoel/\n</code></pre> <p>Alternatively, use ssh: <pre><code>git clone git@github.com:rentruewang/bocoel\ncd bocoel/\n</code></pre></p> <p>I'm using PDM in this project for dependency management. To install all dependencies (including development dependencies) with <code>pdm</code>, run</p> <pre><code>pdm install -G:all\n</code></pre> <p>Alternatively, use of <code>pip</code> is also allowed (although might be less robust due to lack of version solving)</p> <pre><code>pip install -e .\n</code></pre> <p>Both commands perform an editable installation.</p>"},{"location":"CONTRIBUTING/#recommended-development-style","title":"Recommended development style","text":""},{"location":"CONTRIBUTING/#python-code-style","title":"Python code style","text":"<p>The code style in the project closely follows the recommended standard of python:</p> <ol> <li>PEP8</li> <li>Class imports are non-qualified (<code>from module.path import ClassName</code>), and do not use unqualified function names (however, upper case functions acting as classes are treated as classes, lower case classes are treated as functions).</li> <li>All other imports are qualified.</li> <li>TODO:</li> </ol>"},{"location":"CONTRIBUTING/#formatting","title":"Formatting","text":"<p>Use <code>autoflake</code>, <code>isort</code>, <code>black</code> for consistent formatting.</p> <p>Prior to commiting, please run the following commands:</p> <pre><code>autoflake -i $(find -iname \"*.py\" ! -path '*/.venv/*' ! -name __init__.py) --remove-all-unused-imports\nisort . --profile black\nblack .\n</code></pre>"},{"location":"CONTRIBUTING/#typing","title":"Typing","text":"<p>Be sure to run <code>mypy</code> prior to submitting! There can be issue with <code>mypy</code> not finding libraries. The command I use for checking is</p> <pre><code>mypy . --disable-error-code=import-untyped --disable-error-code=import-not-found\n</code></pre>"},{"location":"CONTRIBUTING/#commit-message","title":"Commit message","text":"<p>Add an emoji that best describes this commit a the start of the commit message. This helps makes the project look good on GitHub.</p>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright (c) 2024 RenChu Wang</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"research/","title":"Research","text":"<p>This page is a work in progress. More experiments would be added and the page would be prettier in the future.</p>"},{"location":"research/#bocoel","title":"\u2602\ufe0f BoCoEL","text":""},{"location":"research/#bayesian-optimization-as-a-coverage-tool-for-evaluating-large-language-models","title":"Bayesian Optimization as a Coverage Tool for Evaluating Large Language Models","text":""},{"location":"research/#why-bocoel","title":"\ud83e\udd14 Why BoCoEL?","text":"<p>Large language models are expensive and slow behemoths, and evaluating them on gigantic modern datasets only makes it worse. </p> <p>If only there is a way to just select a meaningful (and small) subset of the corpus and obtain a highly accurate evaluation.....</p> <p>Wait, sounds like Bayesian Optimization!</p> <p>Bocoel works in the following steps:</p> <ol> <li>Encode individual entry into embeddings (way cheaper / faster than LLM and reusable).</li> <li>Use Bayesian optimization to select queries to evaluate.</li> <li>Use the queries to retrieve from our corpus (with the encoded embeddings).</li> <li>Profit.</li> </ol> <p>The evaluations generated are easily managed by the provided manager utility.</p> <p>To our knowledge, this is the first work aiming to reduce computation costs during evaluation (benchmarking) with a (possibly dynamic) budget.</p>"},{"location":"research/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83c\udfaf Accurately evaluate large language models with just tens of samples from your selected corpus.</li> <li>\ud83d\udc82\u200d\u2642\ufe0f Uses the power of Bayesian optimization to select an optimal subset of samples for language model to evaluate.</li> <li>\ud83d\udcaf Evalutes the corpus on the model in addition to evaluating the model on corpus.</li> <li>\ud83e\udd17 Support for <code>GPT2</code>, <code>Pythia</code>, <code>LLAMA</code> and more through integration with huggingface transformers and datasets</li> <li>\ud83e\udde9 Modular design.</li> <li>\ud83d\udd0e Efficient representation of the corpus / dataset such as N-sphere representation or whitening of the latent space to agument evaluation quality.</li> </ul>"},{"location":"research/#give-us-a-star","title":"\u2b50 Give us a star!","text":"<p>Like what you see? Please consider giving this a star (\u2605)!</p>"},{"location":"research/#bayesian-optimization","title":"\u267e\ufe0f Bayesian Optimization","text":"<p>Simply put, Bayesian optimization aims to optimize either the exploration objective (the purple area in the image) or the exploitation object (the height of the black dots). It uses Gaussian processes as a backbone for inference, and uses an acquisition function to decide where to sample next. See here for an a more in-depth introduction.</p> <p>Since Bayesian optimization works well with expensive-to-evaluate black-box model (paraphrase: LLM), it is perfect for this particular use case. Bocoel uses Bayesian optimization as a backbone for exploring the embedding space given by our corpus, which allows it to select a good subset acting as a mini snapshot of the corpus.</p>"},{"location":"research/#performance-implications","title":"\ud83c\udfce\ufe0f Performance Implications","text":"<p>LLMs are painfully slow, especially generative ones (which is what is usually referred to as LLM), since sequence generation is sequential by nature.</p> <p>Despite <code>bocoel</code>'s requirement to use an embedder to encode the entire corpus, embedders are faster than LLMs by orders of magnitude and the time is gained back by practically any savings in evaluating LLMs.</p>"},{"location":"research/#installation","title":"\u2b07\ufe0f Installation","text":"<p>I don't want optional dependencies:</p> <pre><code>pip install bocoel\n</code></pre> <p>Give me the full experience (all optional dependencies):</p> <pre><code>pip install \"bocoel[all]\"\n</code></pre>"},{"location":"research/#usage","title":"\ud83d\udd2c Usage","text":"<p>See the folder examples/getting_started for a simplistic usage of the library to get started with just a few lines of code.</p>"},{"location":"research/#develop-with-bocoel","title":"\u270d\ufe0f Develop with BoCoEL","text":"<p>Usage examples are under the folder <code>examples</code>. API reference can be found here.</p>"},{"location":"research/#contributing","title":"\ud83e\udd70 Contributing","text":"<p>Contributors wanted! Don't be shy. Feel free to file issues and PRs. For PRs, please follow the guide on contributing and the code of conduct. Openness and inclusiveness are taken very seriously.</p>"},{"location":"research/#roadmap-work-in-progress","title":"\ud83d\uddfa\ufe0f Roadmap: work in progress","text":"<ul> <li>\ud83e\ude91 Simpler usage. I should provide a high level wrapper for the entire library s.t. evaluations can be run in one line.</li> <li>\ud83d\udcca Visualization module of the evaluation.</li> <li>\ud83c\udfb2 Integration of alternative methods (random, kmedoids...) with Gaussian process.</li> <li>\ud83e\udd68 Integration with more backends such as VLLM and OpenAI's API.</li> <li>\ud83c\udd95 Support for Python 3.11+</li> </ul>"},{"location":"research/#license-and-citation","title":"\ud83c\udff7\ufe0f License and Citation","text":"<p>The code is available under Apache License.</p> <p>If you find this project helpful in your research, please cite this work at</p> <pre><code>@misc{bocoel2024,\n    title = {BoCoEL: Bayesian Optimization as a Coverage Tool for Evaluating Large Language Models},\n    url = {https://rentruewang.github.io/bocoel/research/},\n    author = {Wang, RenChu},\n    month = {January},\n    year = {2024}\n}\n</code></pre>"},{"location":"research/#abstract","title":"Abstract","text":"<p>BoCoEL, short for Bayesian Optimization as a Coverage Tool for Evaluating Large Language Models, represents an innovative approach in the domain of natural language processing (NLP). This framework leverages Bayesian optimization to efficiently evaluate large language models (LLMs) using a significantly reduced yet representative subset of data from extensive corpora. By encoding the data into embeddings and utilizing Bayesian optimization for sample selection, BoCoEL offers a cost-effective and time-efficient alternative for the evaluation of LLMs. This document delineates the methodology, experimentation, and implications of BoCoEL, highlighting its potential to revolutionize the evaluation process in NLP.</p>"},{"location":"research/#introduction","title":"Introduction","text":"<p>The recent proliferation of large language models (LLMs) in NLP has underscored the necessity for efficient evaluation mechanisms. Traditional methods, which involve the assessment of LLMs over vast datasets, are not only time-consuming but also computationally expensive. BoCoEL addresses this challenge by integrating Bayesian optimization into the evaluation process. This approach not only reduces the computational burden but also maintains the integrity and accuracy of the evaluation. The introduction section will further elaborate on the motivation, background, and the specific challenges BoCoEL aims to address in the realm of LLM evaluation.</p>"},{"location":"research/#methods","title":"Methods","text":"<p>The core methodology of BoCoEL revolves around the use of Bayesian Optimization and embeddings to efficiently evaluate large language models (LLMs). This section provides a detailed mathematical overview of these processes.</p>"},{"location":"research/#embedding-process","title":"Embedding Process","text":"<p>The embedding process involves transforming corpus entries into a vector space, facilitating efficient manipulation and comparison. Let \\(\\mathcal{D}\\) be our dataset containing \\(N\\) entries, \\(\\mathcal{D} = \\{d_1, d_2, ..., d_N\\}\\). Each entry \\(d_i\\) is transformed into an embedding vector \\(\\mathbf{e}_i\\) using an embedding function \\(E\\):</p> <p>\\(\\mathbf{e}_i = E(d_i)\\)</p> <p>These embeddings are then used as inputs for the Bayesian Optimization process.</p>"},{"location":"research/#bayesian-optimization_1","title":"Bayesian Optimization","text":"<p>Bayesian Optimization (BO) is a strategy for global optimization of black-box functions that are expensive to evaluate. It works well with the LLM evaluation problem, as each evaluation can be computationally intensive.</p> <p>Let \\(f: \\mathcal{X} \\rightarrow \\mathbb{R}\\) be the expensive black-box function we wish to optimize, where \\(\\mathcal{X}\\) is the space of parameters (in our case, the space of embeddings). BO approximates \\(f\\) using a surrogate model, typically a Gaussian Process (GP). A GP is defined by its mean function \\(m(\\mathbf{x})\\) and covariance function \\(k(\\mathbf{x}, \\mathbf{x'})\\), where \\(\\mathbf{x}, \\mathbf{x'} \\in \\mathcal{X}\\):</p> <p>\\(m(\\mathbf{x}) = \\mathbb{E}[f(\\mathbf{x})]\\) \\(k(\\mathbf{x}, \\mathbf{x'}) = \\mathbb{E}[(f(\\mathbf{x}) - m(\\mathbf{x}))(f(\\mathbf{x'}) - m(\\mathbf{x'}))]\\)</p> <p>The GP posterior distribution after observing data \\(\\mathcal{D}_n = \\{(\\mathbf{x}_1, y_1), ..., (\\mathbf{x}_n, y_n)\\}\\) is also a GP:</p> <p>\\(f(\\mathbf{x}) | \\mathcal{D}_n \\sim \\mathcal{GP}(\\mu_n(\\mathbf{x}), \\sigma_n^2(\\mathbf{x}))\\)</p> <p>where</p> <p>\\(\\mu_n(\\mathbf{x}) = k_n(\\mathbf{x})^T(K_n + \\sigma^2I)^{-1}Y_n\\) \\(\\sigma_n^2(\\mathbf{x}) = k(\\mathbf{x}, \\mathbf{x}) - k_n(\\mathbf{x})^T(K_n + \\sigma^2I)^{-1}k_n(\\mathbf{x})\\)</p> <p>with \\(k_n(\\mathbf{x}) = [k(\\mathbf{x}_1, \\mathbf{x}), ..., k(\\mathbf{x}_n, \\mathbf{x})]^T\\), \\(K_n\\) being the covariance matrix formed by applying \\(k\\) to all pairs of points in \\(\\mathcal{D}_n\\), and \\(Y_n = [y_1, ..., y_n]^T\\).</p> <p>An acquisition function \\(a: \\mathcal{X} \\rightarrow \\mathbb{R}\\) is used to determine where to sample next, balancing exploration and exploitation. Common choices for \\(a\\) include Expected Improvement (EI) and Upper Confidence Bound (UCB).</p> <p>\\(\\text{EI}(\\mathbf{x}) = \\mathbb{E}[\\max(f(\\mathbf{x}) - f(\\mathbf{x}^+), 0)]\\) \\(\\text{UCB}(\\mathbf{x}) = \\mu_n(\\mathbf{x}) + \\kappa \\sigma_n(\\mathbf{x})\\)</p> <p>where \\(\\mathbf{x}^+\\) is the current best observation, and \\(\\kappa\\) is a parameter controlling the exploration-exploitation trade-off.</p> <p>Here, an entropy search (ES) scheme is used during our evaluation process. This exploration-focused objective ensures that the bayesian process covers as much of the search space with as few samples as possible, which solves the coverage problem (of the embedding space) effectively.</p> <p>Using this framework, BoCoEL iteratively selects samples from \\(\\mathcal{X}\\) (the embedding space) to evaluate the LLM, efficiently optimizing the evaluation process.</p>"},{"location":"research/#experiments","title":"Experiments","text":"<p>TODO: Add plot TODO: Explain the experiments</p> <p>The experimental section will present the application of BoCoEL in various scenarios, demonstrating its effectiveness in evaluating different LLMs. Comparative analyses between BoCoEL and traditional evaluation methods will be highlighted, showcasing the efficiency gains in terms of computational resources and time. This section will also include case studies or real-world examples where BoCoEL has been successfully implemented. The results obtained from these experiments will serve to validate the efficacy of the BoCoEL framework in providing accurate evaluations of LLMs using a significantly reduced dataset.</p>"},{"location":"research/#authors-acknowledgement","title":"Authors &amp; Acknowledgement","text":"<p>TODO: Add authors.</p> <p>See the thank you page for details.</p>"},{"location":"thanks/","title":"Appreciation","text":"<p>This page is dedicated to our contributors.</p> Person Github Link Contributions RenChu Wang Me. Main author and lead developer on the project. And I came up with the idea. Without me this project wouldn't happen. Yung-Sung Chuang Thanks for helping me figure out the design of experiments and the LLM research side of things. Chien-Yi Yang Thanks for helping me understand the math foundation of Bayesian optimization. And finding out a few bugs in the Ax library. Che-Ting Meng Thanks for the visualization parts. Without you I would have to do them myself and that's a nightmare. Sraven Jayanthi This idea came up during our dicussion on dynamically routing between LLMs. Gautham Eyunni Thanks for the very nice looking vector graphics logo."},{"location":"references/adaptors/","title":"Adaptors","text":""},{"location":"references/adaptors/#bocoel.models.adaptors","title":"bocoel.models.adaptors","text":""},{"location":"references/adaptors/#bocoel.Adaptor","title":"bocoel.Adaptor","text":"<p>             Bases: <code>Protocol</code></p> <p>Adaptors are the glue between scores and the corpus. It is designed to handle running a particular score on a particular corpus / dataset.</p>"},{"location":"references/adaptors/#bocoel.Adaptor.evaluate","title":"evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate(data: Mapping[str, Sequence[Any]]) -&gt; Sequence[float] | NDArray\n</code></pre> <p>Evaluate a particular set of entries with a language model. Returns a list of scores, one for each entry, in the same order.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping[str, Sequence[Any]]</code> <p>A mapping from column names to the data in that column.</p> required <p>Returns:</p> Type Description <code>Sequence[float] | NDArray</code> <p>The scores for each entry. Scores must be floating point numbers.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>@abc.abstractmethod\ndef evaluate(self, data: Mapping[str, Sequence[Any]]) -&gt; Sequence[float] | NDArray:\n    \"\"\"\n    Evaluate a particular set of entries with a language model.\n    Returns a list of scores, one for each entry, in the same order.\n\n    Parameters:\n        data: A mapping from column names to the data in that column.\n\n    Returns:\n        The scores for each entry. Scores must be floating point numbers.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/adaptors/#bocoel.Adaptor.on_storage","title":"on_storage","text":"<pre><code>on_storage(storage: Storage, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a storage. Given indices and a storage, this method will extract the corresponding entries from the storage, and evaluate them with <code>Adaptor.evaluate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_storage(self, storage: Storage, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a storage.\n    Given indices and a storage,\n    this method will extract the corresponding entries from the storage,\n    and evaluate them with `Adaptor.evaluate`.\n\n    Parameters:\n        storage: The storage to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    indices = np.array(indices).astype(\"i\")\n\n    # Reshape the indices into 1D to evaluate.\n    indices_shape = indices.shape\n    indices = indices.ravel()\n\n    items = storage[indices.tolist()]\n    result = np.array(self.evaluate(data=items))\n\n    # Reshape back.\n    return result.reshape(indices_shape)\n</code></pre>"},{"location":"references/adaptors/#bocoel.Adaptor.on_corpus","title":"on_corpus","text":"<pre><code>on_corpus(corpus: Corpus, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a corpus. A convenience wrapper around <code>Adaptor.on_storage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corpus</code> <code>Corpus</code> <p>The corpus to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_corpus(self, corpus: Corpus, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a corpus.\n    A convenience wrapper around `Adaptor.on_storage`.\n\n    Parameters:\n        corpus: The corpus to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    return self.on_storage(storage=corpus.storage, indices=indices)\n</code></pre>"},{"location":"references/adaptors/#bocoel.GlueAdaptor","title":"bocoel.GlueAdaptor","text":"<pre><code>GlueAdaptor(\n    lm: ClassifierModel,\n    texts: str = \"text\",\n    label: str = \"label\",\n    label_text: str = \"label_text\",\n    choices: Sequence[str] = (\"negative\", \"positive\"),\n)\n</code></pre> <p>             Bases: <code>Adaptor</code></p> <p>The adaptor for the glue dataset provided by setfit.</p> <p>Glue is a collection of datasets for natural language understanding tasks. The datasets are designed to be challenging and diverse, and they are collected from a variety of sources. They are mostly sentence-level classification tasks.</p> <p>This adaptor is compatible with all classifier models, and it is designed to work with the glue dataset (in the format of setfit datasets on huggingface datasets).</p> <p>Setfit datasets have the following columns:</p> <ul> <li>text: The text to classify.</li> <li>label: The label of the text.</li> <li>label_text: The text of the label.</li> </ul> <p>Initialize the adaptor.</p> <p>Parameters:</p> Name Type Description Default <code>lm</code> <code>ClassifierModel</code> <p>The language model to use for classification.</p> required <code>texts</code> <code>str</code> <p>The column name for the text to classify.</p> <code>'text'</code> <code>label</code> <code>str</code> <p>The column name for the label of the text.</p> <code>'label'</code> <code>label_text</code> <code>str</code> <p>The column name for the text of the label.</p> <code>'label_text'</code> <code>choices</code> <code>Sequence[str]</code> <p>The valid choices for the label.</p> <code>('negative', 'positive')</code> Source code in <code>src/bocoel/models/adaptors/glue/setfit.py</code> <pre><code>def __init__(\n    self,\n    lm: ClassifierModel,\n    texts: str = \"text\",\n    label: str = \"label\",\n    label_text: str = \"label_text\",\n    choices: Sequence[str] = (\"negative\", \"positive\"),\n) -&gt; None:\n    \"\"\"\n    Initialize the adaptor.\n\n    Parameters:\n        lm: The language model to use for classification.\n        texts: The column name for the text to classify.\n        label: The column name for the label of the text.\n        label_text: The column name for the text of the label.\n        choices: The valid choices for the label.\n    \"\"\"\n\n    self.lm = lm\n\n    self.texts = texts.split()\n    self.label = label\n    self.label_text = label_text\n    self.choices = choices\n</code></pre>"},{"location":"references/adaptors/#bocoel.GlueAdaptor.on_storage","title":"on_storage","text":"<pre><code>on_storage(storage: Storage, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a storage. Given indices and a storage, this method will extract the corresponding entries from the storage, and evaluate them with <code>Adaptor.evaluate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_storage(self, storage: Storage, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a storage.\n    Given indices and a storage,\n    this method will extract the corresponding entries from the storage,\n    and evaluate them with `Adaptor.evaluate`.\n\n    Parameters:\n        storage: The storage to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    indices = np.array(indices).astype(\"i\")\n\n    # Reshape the indices into 1D to evaluate.\n    indices_shape = indices.shape\n    indices = indices.ravel()\n\n    items = storage[indices.tolist()]\n    result = np.array(self.evaluate(data=items))\n\n    # Reshape back.\n    return result.reshape(indices_shape)\n</code></pre>"},{"location":"references/adaptors/#bocoel.GlueAdaptor.on_corpus","title":"on_corpus","text":"<pre><code>on_corpus(corpus: Corpus, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a corpus. A convenience wrapper around <code>Adaptor.on_storage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corpus</code> <code>Corpus</code> <p>The corpus to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_corpus(self, corpus: Corpus, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a corpus.\n    A convenience wrapper around `Adaptor.on_storage`.\n\n    Parameters:\n        corpus: The corpus to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    return self.on_storage(storage=corpus.storage, indices=indices)\n</code></pre>"},{"location":"references/adaptors/#bocoel.GlueAdaptor.task_choices","title":"task_choices  <code>staticmethod</code>","text":"<pre><code>task_choices(\n    name: Literal[\"sst2\", \"mrpc\", \"mnli\", \"qqp\", \"rte\", \"qnli\"],\n    split: Literal[\"train\", \"validation\", \"test\"],\n) -&gt; Sequence[str]\n</code></pre> <p>Get the valid choices for a particular task and split.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Literal['sst2', 'mrpc', 'mnli', 'qqp', 'rte', 'qnli']</code> <p>The name of the task.</p> required <code>split</code> <code>Literal['train', 'validation', 'test']</code> <p>The split of the task.</p> required <p>Returns:</p> Type Description <code>Sequence[str]</code> <p>The valid choices for the task and split.</p> Source code in <code>src/bocoel/models/adaptors/glue/setfit.py</code> <pre><code>@staticmethod\ndef task_choices(\n    name: Literal[\"sst2\", \"mrpc\", \"mnli\", \"qqp\", \"rte\", \"qnli\"],\n    split: Literal[\"train\", \"validation\", \"test\"],\n) -&gt; Sequence[str]:\n    \"\"\"\n    Get the valid choices for a particular task and split.\n\n    Parameters:\n        name: The name of the task.\n        split: The split of the task.\n\n    Returns:\n        The valid choices for the task and split.\n    \"\"\"\n\n    LOGGER.debug(\"Getting choices for task\", task=name)\n\n    # Perform checks for supported kinds of datasets.\n    match name:\n        case \"sst2\" | \"mrpc\" | \"mnli\" | \"qqp\" | \"rte\" | \"qnli\":\n            pass\n        case _:\n            raise ValueError(f\"Unknown task name {name}\")\n\n    # Perform checks for supported kinds of splits.\n    match split:\n        case \"train\" | \"validation\" | \"test\":\n            pass\n        case _:\n            raise ValueError(f\"Unknown split {split}\")\n\n    # The actual mux.\n    match name, split:\n        case \"sst2\", _:\n            return [\"negative\", \"positive\"]\n        case \"mrpc\", _:\n            return [\"not equivalent\", \"equivalent\"]\n        # All following cases all use \"unlabeled\" for \"test\".\n        case _, \"test\":\n            return [\"unlabeled\"]\n        case \"mnli\", _:\n            return [\"entailment\", \"neutral\", \"contradiction\"]\n        case \"qqp\", _:\n            return [\"not duplicate\", \"duplicate\"]\n        case \"rte\", _:\n            return [\"entailment\", \"not entailment\"]\n        case \"qnli\", _:\n            return [\"entailment\", \"not entailment\"]\n\n    raise RuntimeError(\"Unreachable\")\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchAdaptor","title":"bocoel.BigBenchAdaptor","text":"<p>             Bases: <code>Adaptor</code>, <code>Protocol</code></p>"},{"location":"references/adaptors/#bocoel.BigBenchAdaptor.evaluate","title":"evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate(data: Mapping[str, Sequence[Any]]) -&gt; Sequence[float] | NDArray\n</code></pre> <p>Evaluate a particular set of entries with a language model. Returns a list of scores, one for each entry, in the same order.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping[str, Sequence[Any]]</code> <p>A mapping from column names to the data in that column.</p> required <p>Returns:</p> Type Description <code>Sequence[float] | NDArray</code> <p>The scores for each entry. Scores must be floating point numbers.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>@abc.abstractmethod\ndef evaluate(self, data: Mapping[str, Sequence[Any]]) -&gt; Sequence[float] | NDArray:\n    \"\"\"\n    Evaluate a particular set of entries with a language model.\n    Returns a list of scores, one for each entry, in the same order.\n\n    Parameters:\n        data: A mapping from column names to the data in that column.\n\n    Returns:\n        The scores for each entry. Scores must be floating point numbers.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchAdaptor.on_storage","title":"on_storage","text":"<pre><code>on_storage(storage: Storage, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a storage. Given indices and a storage, this method will extract the corresponding entries from the storage, and evaluate them with <code>Adaptor.evaluate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_storage(self, storage: Storage, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a storage.\n    Given indices and a storage,\n    this method will extract the corresponding entries from the storage,\n    and evaluate them with `Adaptor.evaluate`.\n\n    Parameters:\n        storage: The storage to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    indices = np.array(indices).astype(\"i\")\n\n    # Reshape the indices into 1D to evaluate.\n    indices_shape = indices.shape\n    indices = indices.ravel()\n\n    items = storage[indices.tolist()]\n    result = np.array(self.evaluate(data=items))\n\n    # Reshape back.\n    return result.reshape(indices_shape)\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchAdaptor.on_corpus","title":"on_corpus","text":"<pre><code>on_corpus(corpus: Corpus, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a corpus. A convenience wrapper around <code>Adaptor.on_storage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corpus</code> <code>Corpus</code> <p>The corpus to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_corpus(self, corpus: Corpus, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a corpus.\n    A convenience wrapper around `Adaptor.on_storage`.\n\n    Parameters:\n        corpus: The corpus to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    return self.on_storage(storage=corpus.storage, indices=indices)\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchQuestionAnswer","title":"bocoel.BigBenchQuestionAnswer","text":"<pre><code>BigBenchQuestionAnswer(\n    lm: GenerativeModel,\n    inputs: str = \"inputs\",\n    targets: str = \"targets\",\n    matching_type: str | BigBenchMatchType = BigBenchMatchType.EXACT,\n)\n</code></pre> <p>             Bases: <code>BigBenchAdaptor</code></p> Source code in <code>src/bocoel/models/adaptors/bigbench/matching.py</code> <pre><code>def __init__(\n    self,\n    lm: GenerativeModel,\n    inputs: str = \"inputs\",\n    targets: str = \"targets\",\n    matching_type: str | BigBenchMatchType = BigBenchMatchType.EXACT,\n) -&gt; None:\n    self.lm = lm\n\n    self.inputs = inputs\n    self.targets = targets\n\n    self._matching_type = BigBenchMatchType.lookup(matching_type)\n    self._score_fn = self._matching_type.score\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchQuestionAnswer.on_storage","title":"on_storage","text":"<pre><code>on_storage(storage: Storage, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a storage. Given indices and a storage, this method will extract the corresponding entries from the storage, and evaluate them with <code>Adaptor.evaluate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_storage(self, storage: Storage, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a storage.\n    Given indices and a storage,\n    this method will extract the corresponding entries from the storage,\n    and evaluate them with `Adaptor.evaluate`.\n\n    Parameters:\n        storage: The storage to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    indices = np.array(indices).astype(\"i\")\n\n    # Reshape the indices into 1D to evaluate.\n    indices_shape = indices.shape\n    indices = indices.ravel()\n\n    items = storage[indices.tolist()]\n    result = np.array(self.evaluate(data=items))\n\n    # Reshape back.\n    return result.reshape(indices_shape)\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchQuestionAnswer.on_corpus","title":"on_corpus","text":"<pre><code>on_corpus(corpus: Corpus, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a corpus. A convenience wrapper around <code>Adaptor.on_storage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corpus</code> <code>Corpus</code> <p>The corpus to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_corpus(self, corpus: Corpus, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a corpus.\n    A convenience wrapper around `Adaptor.on_storage`.\n\n    Parameters:\n        corpus: The corpus to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    return self.on_storage(storage=corpus.storage, indices=indices)\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchMatchType","title":"bocoel.BigBenchMatchType","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"references/adaptors/#bocoel.BigBenchMultipleChoice","title":"bocoel.BigBenchMultipleChoice","text":"<pre><code>BigBenchMultipleChoice(\n    lm: ClassifierModel,\n    inputs: str = \"inputs\",\n    multiple_choice_targets: str = \"multiple_choice_targets\",\n    multiple_choice_scores: str = \"multiple_choice_scores\",\n    choice_type: str | BigBenchChoiceType = BigBenchChoiceType.SUM_OF_SCORES,\n)\n</code></pre> <p>             Bases: <code>BigBenchAdaptor</code></p> Source code in <code>src/bocoel/models/adaptors/bigbench/multi.py</code> <pre><code>def __init__(\n    self,\n    lm: ClassifierModel,\n    inputs: str = \"inputs\",\n    multiple_choice_targets: str = \"multiple_choice_targets\",\n    multiple_choice_scores: str = \"multiple_choice_scores\",\n    choice_type: str | BigBenchChoiceType = BigBenchChoiceType.SUM_OF_SCORES,\n) -&gt; None:\n    self.lm = lm\n\n    self.inputs = inputs\n    self.multiple_choice_targets = multiple_choice_targets\n    self.multiple_choice_scores = multiple_choice_scores\n\n    self._choice_type = BigBenchChoiceType.lookup(choice_type)\n    self._score_fn = self._choice_type.score\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchMultipleChoice.on_storage","title":"on_storage","text":"<pre><code>on_storage(storage: Storage, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a storage. Given indices and a storage, this method will extract the corresponding entries from the storage, and evaluate them with <code>Adaptor.evaluate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_storage(self, storage: Storage, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a storage.\n    Given indices and a storage,\n    this method will extract the corresponding entries from the storage,\n    and evaluate them with `Adaptor.evaluate`.\n\n    Parameters:\n        storage: The storage to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    indices = np.array(indices).astype(\"i\")\n\n    # Reshape the indices into 1D to evaluate.\n    indices_shape = indices.shape\n    indices = indices.ravel()\n\n    items = storage[indices.tolist()]\n    result = np.array(self.evaluate(data=items))\n\n    # Reshape back.\n    return result.reshape(indices_shape)\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchMultipleChoice.on_corpus","title":"on_corpus","text":"<pre><code>on_corpus(corpus: Corpus, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a corpus. A convenience wrapper around <code>Adaptor.on_storage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corpus</code> <code>Corpus</code> <p>The corpus to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_corpus(self, corpus: Corpus, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a corpus.\n    A convenience wrapper around `Adaptor.on_storage`.\n\n    Parameters:\n        corpus: The corpus to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    return self.on_storage(storage=corpus.storage, indices=indices)\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchMultipleChoice.numeric_choices","title":"numeric_choices  <code>staticmethod</code>","text":"<pre><code>numeric_choices(question: str, choices: Sequence[str]) -&gt; str\n</code></pre> <p>Convert a multiple choice question into a numeric choice question. Returns a tuple of generated prompt and list of valid choices.</p> Source code in <code>src/bocoel/models/adaptors/bigbench/multi.py</code> <pre><code>@staticmethod\ndef numeric_choices(question: str, choices: Sequence[str]) -&gt; str:\n    \"\"\"\n    Convert a multiple choice question into a numeric choice question.\n    Returns a tuple of generated prompt and list of valid choices.\n    \"\"\"\n\n    return (\n        f\"{question}\\nSelect from one of the following (answer in number):\\n\"\n        + \"\\n\".join(f\"{i}) {choice}\" for i, choice in enumerate(choices, 1))\n    )\n</code></pre>"},{"location":"references/adaptors/#bocoel.BigBenchChoiceType","title":"bocoel.BigBenchChoiceType","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"references/adaptors/#bocoel.Sst2QuestionAnswer","title":"bocoel.Sst2QuestionAnswer","text":"<pre><code>Sst2QuestionAnswer(\n    lm: ClassifierModel,\n    sentence: str = \"sentence\",\n    label: str = \"label\",\n    choices: Sequence[str] = (\"negative\", \"positive\"),\n)\n</code></pre> <p>             Bases: <code>Adaptor</code></p> <p>The adaptor for the SST-2 dataset. This adaptor assumes that the dataset has the following columns: - <code>idx</code>: The index of the entry. - <code>sentence</code>: The sentence to classify. - <code>label</code>: The label of the sentence.</p> <p>Each entry in the dataset must be a single sentence.</p> <p>Parameters:</p> Name Type Description Default <code>lm</code> <code>ClassifierModel</code> <p>The language model to use for classification.</p> required <code>sentence</code> <code>str</code> <p>The column name for the sentence to classify.</p> <code>'sentence'</code> <code>label</code> <code>str</code> <p>The column name for the label of the sentence.</p> <code>'label'</code> <code>choices</code> <code>Sequence[str]</code> <p>The valid choices for the label.</p> <code>('negative', 'positive')</code> Source code in <code>src/bocoel/models/adaptors/glue/sst.py</code> <pre><code>def __init__(\n    self,\n    lm: ClassifierModel,\n    sentence: str = \"sentence\",\n    label: str = \"label\",\n    choices: Sequence[str] = (\"negative\", \"positive\"),\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        lm: The language model to use for classification.\n        sentence: The column name for the sentence to classify.\n        label: The column name for the label of the sentence.\n        choices: The valid choices for the label.\n    \"\"\"\n\n    self.lm = lm\n\n    self.sentence = sentence\n    self.label = label\n    self.choices = choices\n</code></pre>"},{"location":"references/adaptors/#bocoel.Sst2QuestionAnswer.on_storage","title":"on_storage","text":"<pre><code>on_storage(storage: Storage, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a storage. Given indices and a storage, this method will extract the corresponding entries from the storage, and evaluate them with <code>Adaptor.evaluate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_storage(self, storage: Storage, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a storage.\n    Given indices and a storage,\n    this method will extract the corresponding entries from the storage,\n    and evaluate them with `Adaptor.evaluate`.\n\n    Parameters:\n        storage: The storage to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    indices = np.array(indices).astype(\"i\")\n\n    # Reshape the indices into 1D to evaluate.\n    indices_shape = indices.shape\n    indices = indices.ravel()\n\n    items = storage[indices.tolist()]\n    result = np.array(self.evaluate(data=items))\n\n    # Reshape back.\n    return result.reshape(indices_shape)\n</code></pre>"},{"location":"references/adaptors/#bocoel.Sst2QuestionAnswer.on_corpus","title":"on_corpus","text":"<pre><code>on_corpus(corpus: Corpus, indices: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluate a particular set of indices on a corpus. A convenience wrapper around <code>Adaptor.on_storage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corpus</code> <code>Corpus</code> <p>The corpus to evaluate.</p> required <code>indices</code> <code>ArrayLike</code> <p>The indices to evaluate.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry. The shape must be the same as the indices.</p> Source code in <code>src/bocoel/models/adaptors/interfaces/adaptors.py</code> <pre><code>def on_corpus(self, corpus: Corpus, indices: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Evaluate a particular set of indices on a corpus.\n    A convenience wrapper around `Adaptor.on_storage`.\n\n    Parameters:\n        corpus: The corpus to evaluate.\n        indices: The indices to evaluate.\n\n    Returns:\n        The scores for each entry. The shape must be the same as the indices.\n    \"\"\"\n\n    return self.on_storage(storage=corpus.storage, indices=indices)\n</code></pre>"},{"location":"references/corpora/","title":"Corpus","text":""},{"location":"references/corpora/#bocoel.Corpus","title":"bocoel.Corpus","text":"<p>             Bases: <code>Protocol</code></p> <p>Corpus is the entry point to handling the data in this library.</p> <p>A corpus has 3 main components: - Index: Searches one particular column in the storage.Provides fast retrival. - Storage: Used to store the questions / answers / texts. - Embedder: Embeds the text into vectors for faster access.</p> <p>An index only corresponds to one key. If search over multiple keys is desired, a new column or a new corpus (with shared storage) should be created.</p>"},{"location":"references/corpora/#bocoel.Corpus.storage","title":"storage  <code>instance-attribute</code>","text":"<pre><code>storage: Storage\n</code></pre> <p>Storage is used to store the questions / answers / etc. Can be viewed as a dataframe of texts.</p>"},{"location":"references/corpora/#bocoel.Corpus.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index: Index\n</code></pre> <p>Index searches one particular column in the storage into vectors.</p>"},{"location":"references/corpora/#bocoel.ComposedCorpus","title":"bocoel.ComposedCorpus  <code>dataclass</code>","text":"<p>             Bases: <code>Corpus</code></p> <p>Simply a collection of components.</p>"},{"location":"references/corpora/#bocoel.ComposedCorpus.index_storage","title":"index_storage  <code>classmethod</code>","text":"<pre><code>index_storage(\n    storage: Storage,\n    embedder: Embedder,\n    keys: Sequence[str],\n    index_backend: type[Index],\n    concat: Callable[[Iterable[Any]], str] = \" [SEP] \".join,\n    **index_kwargs: Any\n) -&gt; Self\n</code></pre> <p>Creates a corpus from the given storage, embedder, key and index class, where storage entries would be mapped to strings,</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to index.</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to use.</p> required <code>keys</code> <code>Sequence[str]</code> <p>The keys to use for the index.</p> required <code>index_backend</code> <code>type[Index]</code> <p>The index class to use.</p> required <code>concat</code> <code>Callable[[Iterable[Any]], str]</code> <p>The function to use to concatenate the keys.</p> <code>join</code> <code>**index_kwargs</code> <code>Any</code> <p>Additional arguments to pass to the index class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The created corpus.</p> Source code in <code>src/bocoel/corpora/corpora/composed.py</code> <pre><code>@classmethod\ndef index_storage(\n    cls,\n    storage: Storage,\n    embedder: Embedder,\n    keys: Sequence[str],\n    index_backend: type[Index],\n    concat: Callable[[Iterable[Any]], str] = \" [SEP] \".join,\n    **index_kwargs: Any,\n) -&gt; Self:\n    \"\"\"\n    Creates a corpus from the given storage, embedder, key and index class,\n    where storage entries would be mapped to strings,\n\n    Parameters:\n        storage: The storage to index.\n        embedder: The embedder to use.\n        keys: The keys to use for the index.\n        index_backend: The index class to use.\n        concat: The function to use to concatenate the keys.\n        **index_kwargs: Additional arguments to pass to the index class.\n\n    Returns:\n        The created corpus.\n    \"\"\"\n\n    def transform(mapping: Mapping[str, Sequence[Any]]) -&gt; Sequence[str]:\n        data = [mapping[k] for k in keys]\n        return [concat(datum) for datum in zip(*data)]\n\n    return cls.index_mapped(\n        storage=storage,\n        embedder=embedder,\n        transform=transform,\n        index_backend=index_backend,\n        **index_kwargs,\n    )\n</code></pre>"},{"location":"references/corpora/#bocoel.ComposedCorpus.index_mapped","title":"index_mapped  <code>classmethod</code>","text":"<pre><code>index_mapped(\n    storage: Storage,\n    embedder: Embedder,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n    index_backend: type[Index],\n    **index_kwargs: Any\n) -&gt; Self\n</code></pre> <p>Creates a corpus from the given storage, embedder, key and index class, where storage entries would be mapped to strings, using the specified batched transform function.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to index.</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to use.</p> required <code>transform</code> <code>Callable[[Mapping[str, Sequence[Any]]], Sequence[str]]</code> <p>The function to use to transform the storage entries.</p> required <code>index_backend</code> <code>type[Index]</code> <p>The index class to use.</p> required <code>**index_kwargs</code> <code>Any</code> <p>Additional arguments to pass to the index class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The created corpus.</p> Source code in <code>src/bocoel/corpora/corpora/composed.py</code> <pre><code>@classmethod\ndef index_mapped(\n    cls,\n    storage: Storage,\n    embedder: Embedder,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n    index_backend: type[Index],\n    **index_kwargs: Any,\n) -&gt; Self:\n    \"\"\"\n    Creates a corpus from the given storage, embedder, key and index class,\n    where storage entries would be mapped to strings,\n    using the specified batched transform function.\n\n    Parameters:\n        storage: The storage to index.\n        embedder: The embedder to use.\n        transform: The function to use to transform the storage entries.\n        index_backend: The index class to use.\n        **index_kwargs: Additional arguments to pass to the index class.\n\n    Returns:\n        The created corpus.\n    \"\"\"\n\n    embeddings = embedder.encode_storage(storage, transform=transform)\n    return cls.index_embeddings(\n        embeddings=embeddings,\n        storage=storage,\n        index_backend=index_backend,\n        **index_kwargs,\n    )\n</code></pre>"},{"location":"references/corpora/#bocoel.ComposedCorpus.index_embeddings","title":"index_embeddings  <code>classmethod</code>","text":"<pre><code>index_embeddings(\n    storage: Storage,\n    embeddings: NDArray,\n    index_backend: type[Index],\n    **index_kwargs: Any\n) -&gt; Self\n</code></pre> <p>Create the corpus with the given embeddings. This can be used to save time by encoding once and caching embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to use.</p> required <code>embeddings</code> <code>NDArray</code> <p>The embeddings to use.</p> required <code>index_backend</code> <code>type[Index]</code> <p>The index class to use.</p> required <code>**index_kwargs</code> <code>Any</code> <p>Additional arguments to pass to the index class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The created corpus.</p> Source code in <code>src/bocoel/corpora/corpora/composed.py</code> <pre><code>@classmethod\ndef index_embeddings(\n    cls,\n    storage: Storage,\n    embeddings: NDArray,\n    index_backend: type[Index],\n    **index_kwargs: Any,\n) -&gt; Self:\n    \"\"\"\n    Create the corpus with the given embeddings.\n    This can be used to save time by encoding once and caching embeddings.\n\n    Parameters:\n        storage: The storage to use.\n        embeddings: The embeddings to use.\n        index_backend: The index class to use.\n        **index_kwargs: Additional arguments to pass to the index class.\n\n    Returns:\n        The created corpus.\n    \"\"\"\n\n    index = index_backend(embeddings, **index_kwargs)\n    return cls(index=index, storage=storage)\n</code></pre>"},{"location":"references/embedders/","title":"Embedders","text":""},{"location":"references/embedders/#bocoel.Embedder","title":"bocoel.Embedder","text":"<p>             Bases: <code>Protocol</code></p> <p>Embedders are responsible for encoding text into vectors. Embedders in this project are considered volatile because it requires CPU time, unless some database with encoder capability is used.</p>"},{"location":"references/embedders/#bocoel.Embedder.batch","title":"batch  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>batch: int\n</code></pre> <p>The batch size to use when encoding.</p>"},{"location":"references/embedders/#bocoel.Embedder.dims","title":"dims  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>dims: int\n</code></pre> <p>The dimensions of the embeddings</p>"},{"location":"references/embedders/#bocoel.Embedder.encode_storage","title":"encode_storage","text":"<pre><code>encode_storage(\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray\n</code></pre> <p>Encodes the storage into embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to encode.</p> required <code>transform</code> <code>Callable[[Mapping[str, Sequence[Any]]], Sequence[str]]</code> <p>The transformation function to use.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(storage), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode_storage(\n    self,\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray:\n    \"\"\"\n    Encodes the storage into embeddings.\n\n    Parameters:\n        storage: The storage to encode.\n        transform: The transformation function to use.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(storage), self.dims]`.\n    \"\"\"\n\n    results: list[NDArray] = []\n\n    for idx in tqdm(range(0, len(storage), self.batch)):\n        LOGGER.debug(\n            \"Encoding storage\",\n            storage=storage,\n            batch_size=self.batch,\n            idx=idx,\n            total=len(storage),\n        )\n        batch = storage[idx : idx + self.batch]\n        texts = transform(batch)\n        encoded = self.encode(texts)\n        results.append(encoded)\n\n    return np.concatenate(results, axis=0)\n</code></pre>"},{"location":"references/embedders/#bocoel.Embedder.encode","title":"encode","text":"<pre><code>encode(text: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Calls the encode function and performs some checks. Would try to encode the text in batches.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Sequence[str]</code> <p>The text to encode.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(text), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode(self, text: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Calls the encode function and performs some checks.\n    Would try to encode the text in batches.\n\n    Parameters:\n        text: The text to encode.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(text), self.dims]`.\n    \"\"\"\n\n    with torch.no_grad():\n        encoded = self._encode(text)\n\n    if (dim := encoded.shape[-1]) != self.dims:\n        raise ValueError(\n            f\"Expected the encoded embeddings to have dimension {self.dims}, got {dim}\"\n        )\n\n    return encoded.cpu().numpy()\n</code></pre>"},{"location":"references/embedders/#bocoel.Embedder._encode","title":"_encode  <code>abstractmethod</code>","text":"<pre><code>_encode(texts: Sequence[str]) -&gt; Tensor\n</code></pre> <p>The actual encode function.</p> <p>Parameters:</p> Name Type Description Default <code>texts</code> <code>Sequence[str]</code> <p>The texts to encode.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The encoded embeddings. The shape must be <code>[len(texts), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>@abc.abstractmethod\ndef _encode(self, texts: Sequence[str], /) -&gt; Tensor:\n    \"\"\"\n    The actual encode function.\n\n    Parameters:\n        texts: The texts to encode.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(texts), self.dims]`.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/embedders/#bocoel.SbertEmbedder","title":"bocoel.SbertEmbedder","text":"<pre><code>SbertEmbedder(\n    model_name: str = \"all-mpnet-base-v2\",\n    device: str = \"cpu\",\n    batch_size: int = 64,\n)\n</code></pre> <p>             Bases: <code>Embedder</code></p> <p>Sentence-BERT embedder. Uses the sentence_transformers library.</p> <p>Initializes the Sbert embedder.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The model name to use.</p> <code>'all-mpnet-base-v2'</code> <code>device</code> <code>str</code> <p>The device to use.</p> <code>'cpu'</code> <code>batch_size</code> <code>int</code> <p>The batch size for encoding.</p> <code>64</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If sentence_transformers is not installed.</p> Source code in <code>src/bocoel/corpora/embedders/sberts.py</code> <pre><code>def __init__(\n    self,\n    model_name: str = \"all-mpnet-base-v2\",\n    device: str = \"cpu\",\n    batch_size: int = 64,\n) -&gt; None:\n    \"\"\"\n    Initializes the Sbert embedder.\n\n    Parameters:\n        model_name: The model name to use.\n        device: The device to use.\n        batch_size: The batch size for encoding.\n\n    Raises:\n        ImportError: If sentence_transformers is not installed.\n    \"\"\"\n\n    # Optional dependency.\n    from sentence_transformers import SentenceTransformer\n\n    self._name = model_name\n    self._sbert = SentenceTransformer(model_name, device=device)\n\n    self._batch_size = batch_size\n</code></pre>"},{"location":"references/embedders/#bocoel.SbertEmbedder.encode_storage","title":"encode_storage","text":"<pre><code>encode_storage(\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray\n</code></pre> <p>Encodes the storage into embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to encode.</p> required <code>transform</code> <code>Callable[[Mapping[str, Sequence[Any]]], Sequence[str]]</code> <p>The transformation function to use.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(storage), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode_storage(\n    self,\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray:\n    \"\"\"\n    Encodes the storage into embeddings.\n\n    Parameters:\n        storage: The storage to encode.\n        transform: The transformation function to use.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(storage), self.dims]`.\n    \"\"\"\n\n    results: list[NDArray] = []\n\n    for idx in tqdm(range(0, len(storage), self.batch)):\n        LOGGER.debug(\n            \"Encoding storage\",\n            storage=storage,\n            batch_size=self.batch,\n            idx=idx,\n            total=len(storage),\n        )\n        batch = storage[idx : idx + self.batch]\n        texts = transform(batch)\n        encoded = self.encode(texts)\n        results.append(encoded)\n\n    return np.concatenate(results, axis=0)\n</code></pre>"},{"location":"references/embedders/#bocoel.SbertEmbedder.encode","title":"encode","text":"<pre><code>encode(text: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Calls the encode function and performs some checks. Would try to encode the text in batches.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Sequence[str]</code> <p>The text to encode.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(text), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode(self, text: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Calls the encode function and performs some checks.\n    Would try to encode the text in batches.\n\n    Parameters:\n        text: The text to encode.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(text), self.dims]`.\n    \"\"\"\n\n    with torch.no_grad():\n        encoded = self._encode(text)\n\n    if (dim := encoded.shape[-1]) != self.dims:\n        raise ValueError(\n            f\"Expected the encoded embeddings to have dimension {self.dims}, got {dim}\"\n        )\n\n    return encoded.cpu().numpy()\n</code></pre>"},{"location":"references/embedders/#bocoel.HuggingfaceEmbedder","title":"bocoel.HuggingfaceEmbedder","text":"<pre><code>HuggingfaceEmbedder(\n    path: str,\n    device: str = \"cpu\",\n    batch_size: int = 64,\n    transform: Callable[[Any], Tensor] = lambda: output.logits,\n)\n</code></pre> <p>             Bases: <code>Embedder</code></p> <p>Huggingface embedder. Uses the transformers library. Not a traditional encoder but uses a classifier and logits as embeddings.</p> <p>Initializes the Huggingface embedder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the model.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> <code>'cpu'</code> <code>batch_size</code> <code>int</code> <p>The batch size for encoding.</p> <code>64</code> <code>transform</code> <code>Callable[[Any], Tensor]</code> <p>The transformation function to use.</p> <code>lambda : logits</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If transformers is not installed.</p> <code>ValueError</code> <p>If the model does not have a <code>config.id2label</code> attribute.</p> Source code in <code>src/bocoel/corpora/embedders/huggingface.py</code> <pre><code>def __init__(\n    self,\n    path: str,\n    device: str = \"cpu\",\n    batch_size: int = 64,\n    transform: Callable[[Any], Tensor] = lambda output: output.logits,\n) -&gt; None:\n    \"\"\"\n    Initializes the Huggingface embedder.\n\n    Parameters:\n        path: The path to the model.\n        device: The device to use.\n        batch_size: The batch size for encoding.\n        transform: The transformation function to use.\n\n    Raises:\n        ImportError: If transformers is not installed.\n        ValueError: If the model does not have a `config.id2label` attribute.\n    \"\"\"\n\n    # Optional dependency.\n    from transformers import AutoModelForSequenceClassification, AutoTokenizer\n\n    self._path = path\n    self._model = AutoModelForSequenceClassification.from_pretrained(path)\n    self._tokenizer = AutoTokenizer.from_pretrained(path)\n    self._batch_size = batch_size\n\n    self._device = device\n    self._model = self._model.to(device)\n    self._transform = transform\n\n    try:\n        self._dims = len(self._model.config.id2label)\n    except AttributeError as e:\n        raise ValueError(\n            \"The model must have a `config.id2label` attribute to determine the number of classes.\"\n        ) from e\n</code></pre>"},{"location":"references/embedders/#bocoel.HuggingfaceEmbedder.encode_storage","title":"encode_storage","text":"<pre><code>encode_storage(\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray\n</code></pre> <p>Encodes the storage into embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to encode.</p> required <code>transform</code> <code>Callable[[Mapping[str, Sequence[Any]]], Sequence[str]]</code> <p>The transformation function to use.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(storage), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode_storage(\n    self,\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray:\n    \"\"\"\n    Encodes the storage into embeddings.\n\n    Parameters:\n        storage: The storage to encode.\n        transform: The transformation function to use.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(storage), self.dims]`.\n    \"\"\"\n\n    results: list[NDArray] = []\n\n    for idx in tqdm(range(0, len(storage), self.batch)):\n        LOGGER.debug(\n            \"Encoding storage\",\n            storage=storage,\n            batch_size=self.batch,\n            idx=idx,\n            total=len(storage),\n        )\n        batch = storage[idx : idx + self.batch]\n        texts = transform(batch)\n        encoded = self.encode(texts)\n        results.append(encoded)\n\n    return np.concatenate(results, axis=0)\n</code></pre>"},{"location":"references/embedders/#bocoel.HuggingfaceEmbedder.encode","title":"encode","text":"<pre><code>encode(text: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Calls the encode function and performs some checks. Would try to encode the text in batches.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Sequence[str]</code> <p>The text to encode.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(text), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode(self, text: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Calls the encode function and performs some checks.\n    Would try to encode the text in batches.\n\n    Parameters:\n        text: The text to encode.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(text), self.dims]`.\n    \"\"\"\n\n    with torch.no_grad():\n        encoded = self._encode(text)\n\n    if (dim := encoded.shape[-1]) != self.dims:\n        raise ValueError(\n            f\"Expected the encoded embeddings to have dimension {self.dims}, got {dim}\"\n        )\n\n    return encoded.cpu().numpy()\n</code></pre>"},{"location":"references/embedders/#bocoel.EnsembleEmbedder","title":"bocoel.EnsembleEmbedder","text":"<pre><code>EnsembleEmbedder(embedders: Sequence[Embedder], sequential: bool = False)\n</code></pre> <p>             Bases: <code>Embedder</code></p> <p>An ensemble of embedders. The embeddings are concatenated together.</p> <p>Parameters:</p> Name Type Description Default <code>embedders</code> <code>Sequence[Embedder]</code> <p>The embedders to use.</p> required <code>sequential</code> <code>bool</code> <p>Whether to use sequential processing.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the embedders have different batch sizes.</p> Source code in <code>src/bocoel/corpora/embedders/ensemble.py</code> <pre><code>def __init__(self, embedders: Sequence[Embedder], sequential: bool = False) -&gt; None:\n    \"\"\"\n    Parameters:\n        embedders: The embedders to use.\n        sequential: Whether to use sequential processing.\n\n    Raises:\n        ValueError: If the embedders have different batch sizes.\n    \"\"\"\n\n    # Check if all embedders have the same batch size.\n    self._embedders = embedders\n    self._batch_size = embedders[0].batch\n    if len(set(emb.batch for emb in embedders)) != 1:\n        raise ValueError(\"All embedders must have the same batch size\")\n\n    self._sequential = sequential\n\n    cpus = os.cpu_count()\n    assert cpus is not None\n    self._cpus = cpus\n</code></pre>"},{"location":"references/embedders/#bocoel.EnsembleEmbedder.encode_storage","title":"encode_storage","text":"<pre><code>encode_storage(\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray\n</code></pre> <p>Encodes the storage into embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>Storage</code> <p>The storage to encode.</p> required <code>transform</code> <code>Callable[[Mapping[str, Sequence[Any]]], Sequence[str]]</code> <p>The transformation function to use.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(storage), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode_storage(\n    self,\n    storage: Storage,\n    /,\n    transform: Callable[[Mapping[str, Sequence[Any]]], Sequence[str]],\n) -&gt; NDArray:\n    \"\"\"\n    Encodes the storage into embeddings.\n\n    Parameters:\n        storage: The storage to encode.\n        transform: The transformation function to use.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(storage), self.dims]`.\n    \"\"\"\n\n    results: list[NDArray] = []\n\n    for idx in tqdm(range(0, len(storage), self.batch)):\n        LOGGER.debug(\n            \"Encoding storage\",\n            storage=storage,\n            batch_size=self.batch,\n            idx=idx,\n            total=len(storage),\n        )\n        batch = storage[idx : idx + self.batch]\n        texts = transform(batch)\n        encoded = self.encode(texts)\n        results.append(encoded)\n\n    return np.concatenate(results, axis=0)\n</code></pre>"},{"location":"references/embedders/#bocoel.EnsembleEmbedder.encode","title":"encode","text":"<pre><code>encode(text: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Calls the encode function and performs some checks. Would try to encode the text in batches.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Sequence[str]</code> <p>The text to encode.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The encoded embeddings. The shape must be <code>[len(text), self.dims]</code>.</p> Source code in <code>src/bocoel/corpora/embedders/interfaces.py</code> <pre><code>def encode(self, text: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Calls the encode function and performs some checks.\n    Would try to encode the text in batches.\n\n    Parameters:\n        text: The text to encode.\n\n    Returns:\n        The encoded embeddings. The shape must be `[len(text), self.dims]`.\n    \"\"\"\n\n    with torch.no_grad():\n        encoded = self._encode(text)\n\n    if (dim := encoded.shape[-1]) != self.dims:\n        raise ValueError(\n            f\"Expected the encoded embeddings to have dimension {self.dims}, got {dim}\"\n        )\n\n    return encoded.cpu().numpy()\n</code></pre>"},{"location":"references/exams/","title":"Exams","text":""},{"location":"references/exams/#bocoel.core.exams","title":"bocoel.core.exams","text":"<p>The exams module provides the functionality to create and manage exams. Here, an exam is used to measure how well the corpus or the model performs on a given task.</p> <p>The module provides the following functionality:</p> <ul> <li><code>Examinator</code>s are responsible for launch exams.</li> <li><code>Exam</code>s are the tests that take in an accumulated history of model / corpus and returns a score.</li> <li><code>Manager</code>s are responsible for managing results across runs.</li> </ul>"},{"location":"references/exams/#bocoel.Examinator","title":"bocoel.Examinator","text":"<pre><code>Examinator(exams: Mapping[str, Exam])\n</code></pre> <p>The examinator is responsible for launching exams. Examinators take in an index and results of an optimizer run, and return a DataFrame of scores for the accumulated history performance of the optimizer.</p> Source code in <code>src/bocoel/core/exams/examinators.py</code> <pre><code>def __init__(self, exams: Mapping[str, Exam]) -&gt; None:\n    self.exams = exams\n</code></pre>"},{"location":"references/exams/#bocoel.Examinator.examine","title":"examine","text":"<pre><code>examine(index: Index, results: OrderedDict[int, float]) -&gt; DataFrame\n</code></pre> <p>Perform the exams on the results. This method looks up results in the index and runs the exams on the results.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>The index of the results.</p> required <code>results</code> <code>OrderedDict[int, float]</code> <p>The results.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The scores of the exams.</p> TODO <p>Run the different exams in parallel. Currently the exams are run sequentially and can be slow.</p> Source code in <code>src/bocoel/core/exams/examinators.py</code> <pre><code>def examine(self, index: Index, results: OrderedDict[int, float]) -&gt; DataFrame:\n    \"\"\"\n    Perform the exams on the results.\n    This method looks up results in the index and runs the exams on the results.\n\n    Parameters:\n        index: The index of the results.\n        results: The results.\n\n    Returns:\n        The scores of the exams.\n\n    TODO:\n        Run the different exams in parallel.\n        Currently the exams are run sequentially and can be slow.\n    \"\"\"\n\n    scores = {k: v.run(index, results) for k, v in self.exams.items()}\n    original = {\n        exams.STEP_IDX: list(range(len(results))),\n        exams.ORIGINAL: list(results.values()),\n    }\n    return DataFrame.from_dict({**original, **scores})\n</code></pre>"},{"location":"references/exams/#bocoel.Examinator.presets","title":"presets  <code>classmethod</code>","text":"<pre><code>presets() -&gt; Self\n</code></pre> <p>Returns:</p> Type Description <code>Self</code> <p>The default examinator.</p> Source code in <code>src/bocoel/core/exams/examinators.py</code> <pre><code>@classmethod\ndef presets(cls) -&gt; Self:\n    \"\"\"\n    Returns:\n        The default examinator.\n    \"\"\"\n\n    return cls(\n        {\n            exams.ACC_MIN: Accumulation(AccType.MIN),\n            exams.ACC_MAX: Accumulation(AccType.MAX),\n            exams.ACC_AVG: Accumulation(AccType.AVG),\n        }\n    )\n</code></pre>"},{"location":"references/exams/#bocoel.Exam","title":"bocoel.Exam","text":"<p>             Bases: <code>Protocol</code></p> <p>Exams are designed to evaluate the performance of a particular index, using a particular set of results generated by the optimizer.</p>"},{"location":"references/exams/#bocoel.Exam.run","title":"run","text":"<pre><code>run(index: Index, results: OrderedDict[int, float]) -&gt; NDArray\n</code></pre> <p>Run the exam on the given index and results.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>The index to evaluate.</p> required <code>results</code> <code>OrderedDict[int, float]</code> <p>The results generated by the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry in the index. The length must be the same as the results.</p> Source code in <code>src/bocoel/core/exams/interfaces.py</code> <pre><code>def run(self, index: Index, results: OrderedDict[int, float]) -&gt; NDArray:\n    \"\"\"\n    Run the exam on the given index and results.\n\n    Parameters:\n        index: The index to evaluate.\n        results: The results generated by the optimizer.\n\n    Returns:\n        The scores for each entry in the index. The length must be the same as the results.\n    \"\"\"\n\n    outcome = self._run(index=index, results=results)\n\n    if len(outcome) != len(results):\n        raise ValueError(\n            f\"Length of outcome ({len(outcome)}) must be the same as \"\n            f\"the length of results ({len(results)})\"\n        )\n\n    return outcome\n</code></pre>"},{"location":"references/exams/#bocoel.Exam._run","title":"_run  <code>abstractmethod</code>","text":"<pre><code>_run(index: Index, results: OrderedDict[int, float]) -&gt; NDArray\n</code></pre> <p>Run the exam on the given index and results.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>The index to evaluate.</p> required <code>results</code> <code>OrderedDict[int, float]</code> <p>The results generated by the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry in the index. The length must be the same as the results.</p> Source code in <code>src/bocoel/core/exams/interfaces.py</code> <pre><code>@abc.abstractmethod\ndef _run(self, index: Index, results: OrderedDict[int, float]) -&gt; NDArray:\n    \"\"\"\n    Run the exam on the given index and results.\n\n    Parameters:\n        index: The index to evaluate.\n        results: The results generated by the optimizer.\n\n    Returns:\n        The scores for each entry in the index. The length must be the same as the results.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/exams/#bocoel.AccType","title":"bocoel.AccType","text":"<p>             Bases: <code>StrEnum</code></p> <p>Accumulation type.</p>"},{"location":"references/exams/#bocoel.AccType.MIN","title":"MIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MIN = 'MINIMUM'\n</code></pre> <p>Minimum value accumulation.</p>"},{"location":"references/exams/#bocoel.AccType.MAX","title":"MAX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX = 'MAXIMUM'\n</code></pre> <p>Maximum value accumulation.</p>"},{"location":"references/exams/#bocoel.AccType.AVG","title":"AVG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AVG = 'AVERAGE'\n</code></pre> <p>Average value accumulation.</p>"},{"location":"references/exams/#bocoel.Accumulation","title":"bocoel.Accumulation","text":"<pre><code>Accumulation(typ: AccType)\n</code></pre> <p>             Bases: <code>Exam</code></p> <p>Accumulation is an exam designed to evaluate the min / max / avg of the history.</p> Source code in <code>src/bocoel/core/exams/stats/acc.py</code> <pre><code>def __init__(self, typ: AccType) -&gt; None:\n    self._acc_func: Callable[[NDArray], NDArray]\n    match typ:\n        case AccType.MIN:\n            self._acc_func = np.minimum.accumulate\n        case AccType.MAX:\n            self._acc_func = np.maximum.accumulate\n        case AccType.AVG:\n            self._acc_func = lambda arr: np.cumsum(arr) / np.arange(1, arr.size + 1)\n        case _:\n            raise ValueError(f\"Unknown accumulation type {typ}\")\n</code></pre>"},{"location":"references/exams/#bocoel.Accumulation.run","title":"run","text":"<pre><code>run(index: Index, results: OrderedDict[int, float]) -&gt; NDArray\n</code></pre> <p>Run the exam on the given index and results.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>The index to evaluate.</p> required <code>results</code> <code>OrderedDict[int, float]</code> <p>The results generated by the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The scores for each entry in the index. The length must be the same as the results.</p> Source code in <code>src/bocoel/core/exams/interfaces.py</code> <pre><code>def run(self, index: Index, results: OrderedDict[int, float]) -&gt; NDArray:\n    \"\"\"\n    Run the exam on the given index and results.\n\n    Parameters:\n        index: The index to evaluate.\n        results: The results generated by the optimizer.\n\n    Returns:\n        The scores for each entry in the index. The length must be the same as the results.\n    \"\"\"\n\n    outcome = self._run(index=index, results=results)\n\n    if len(outcome) != len(results):\n        raise ValueError(\n            f\"Length of outcome ({len(outcome)}) must be the same as \"\n            f\"the length of results ({len(results)})\"\n        )\n\n    return outcome\n</code></pre>"},{"location":"references/exams/#bocoel.Accumulation._acc","title":"_acc  <code>staticmethod</code>","text":"<pre><code>_acc(array: NDArray, accumulate: Callable[[NDArray], NDArray]) -&gt; NDArray\n</code></pre> <p>Accumulate the array using the given function.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArray</code> <p>The array to accumulate.</p> required <code>accumulate</code> <code>Callable[[NDArray], NDArray]</code> <p>The accumulation function to use.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The accumulated array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array is not 1D.</p> Source code in <code>src/bocoel/core/exams/stats/acc.py</code> <pre><code>@staticmethod\ndef _acc(array: NDArray, accumulate: Callable[[NDArray], NDArray]) -&gt; NDArray:\n    \"\"\"\n    Accumulate the array using the given function.\n\n    Parameters:\n        array: The array to accumulate.\n        accumulate: The accumulation function to use.\n\n    Returns:\n        The accumulated array.\n\n    Raises:\n        ValueError: If the array is not 1D.\n    \"\"\"\n\n    _check_dim(array, 1)\n    result = accumulate(array)\n    _check_dim(result, 1)\n    return result\n</code></pre>"},{"location":"references/exams/#bocoel.Manager","title":"bocoel.Manager","text":"<pre><code>Manager(root: str | Path | None = None, skip_rerun: bool = True)\n</code></pre> <p>The manager for running and saving evaluations.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str | Path | None</code> <p>The path to save the scores to.</p> <code>None</code> <code>skip_rerun</code> <code>bool</code> <p>Whether to skip rerunning the optimizer if the scores already exist.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a directory.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>def __init__(self, root: str | Path | None = None, skip_rerun: bool = True) -&gt; None:\n    \"\"\"\n    Parameters:\n        root: The path to save the scores to.\n        skip_rerun: Whether to skip rerunning the optimizer if the scores already exist.\n\n    Raises:\n        ValueError: If the path is not a directory.\n    \"\"\"\n\n    if root is not None:\n        root = Path(root)\n        if root.exists() and not root.is_dir():\n            raise ValueError(f\"{root} is not a directory\")\n        root.mkdir(parents=True, exist_ok=True)\n\n        # Prevent data from being tracked by git.\n        gitigore = root / \".gitignore\"\n        if not gitigore.exists():\n            with open(gitigore, \"w+\") as f:\n                f.write(\"# Automatically generated by BoCoEL.\\n*\")\n\n    self._start = self.current()\n    self._examinator = Examinator.presets()\n\n    # Public attributes. Can be overwritten at any time.\n    self.root = root\n    self.skip_rerun = skip_rerun\n</code></pre>"},{"location":"references/exams/#bocoel.Manager._examinator","title":"_examinator  <code>instance-attribute</code>","text":"<pre><code>_examinator: Examinator = presets()\n</code></pre> <p>The examinator that would perform evaluations on the results.</p>"},{"location":"references/exams/#bocoel.Manager.run","title":"run","text":"<pre><code>run(\n    steps: int | None = None,\n    *,\n    optimizer: Optimizer,\n    embedder: Embedder,\n    corpus: Corpus,\n    model: GenerativeModel | ClassifierModel,\n    adaptor: Adaptor\n) -&gt; DataFrame\n</code></pre> <p>Runs the optimizer until the end. If the root path is set in the constructor, the scores are saved to the path.</p> <p>Parameters:</p> Name Type Description Default <code>optimizer</code> <code>Optimizer</code> <p>The optimizer to run.</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to run the optimizer with.</p> required <code>corpus</code> <code>Corpus</code> <p>The corpus to run the optimizer on.</p> required <code>model</code> <code>GenerativeModel | ClassifierModel</code> <p>The model to run the optimizer with.</p> required <code>adaptor</code> <code>Adaptor</code> <p>The adaptor to run the optimizer with.</p> required <code>steps</code> <code>int | None</code> <p>The number of steps to run the optimizer for.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The final state of the optimizer. Keys are the indices of the queries, and values are the corresponding scores.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>def run(\n    self,\n    steps: int | None = None,\n    *,\n    optimizer: Optimizer,\n    embedder: Embedder,\n    corpus: Corpus,\n    model: GenerativeModel | ClassifierModel,\n    adaptor: Adaptor,\n) -&gt; DataFrame:\n    \"\"\"\n    Runs the optimizer until the end.\n    If the root path is set in the constructor,\n    the scores are saved to the path.\n\n    Parameters:\n        optimizer: The optimizer to run.\n        embedder: The embedder to run the optimizer with.\n        corpus: The corpus to run the optimizer on.\n        model: The model to run the optimizer with.\n        adaptor: The adaptor to run the optimizer with.\n        steps: The number of steps to run the optimizer for.\n\n    Returns:\n        The final state of the optimizer.\n            Keys are the indices of the queries,\n            and values are the corresponding scores.\n    \"\"\"\n\n    md5 = self.md5(\n        optimizer=optimizer,\n        embedder=embedder,\n        corpus=corpus,\n        model=model,\n        adaptor=adaptor,\n    )\n\n    if self.skip_rerun and self.root is not None and (self.root / md5).exists():\n        LOGGER.warning(\"Previous scores found. Skip\", md5=md5)\n        return self.load(self.root / md5)\n\n    # Run the optimizer and collect the results.\n    LOGGER.info(\"Running the optimizer\", steps=steps)\n    results: OrderedDict[int, float] = OrderedDict()\n    for res in self._launch(optimizer=optimizer, steps=steps):\n        results.update(res)\n\n    # Examine the results.\n    LOGGER.info(\"Examing the results\")\n    scores = self._examinator.examine(index=corpus.index, results=results)\n\n    self.save(\n        scores=scores,\n        optimizer=optimizer,\n        corpus=corpus,\n        model=model,\n        adaptor=adaptor,\n        embedder=embedder,\n        md5=md5,\n    )\n\n    return scores\n</code></pre>"},{"location":"references/exams/#bocoel.Manager.save","title":"save","text":"<pre><code>save(\n    *,\n    scores: DataFrame,\n    optimizer: Optimizer,\n    corpus: Corpus,\n    model: GenerativeModel | ClassifierModel,\n    adaptor: Adaptor,\n    embedder: Embedder,\n    md5: str\n) -&gt; None\n</code></pre> <p>Saves the scores to the path. If the root path is not set in the constructor, the scores are not saved.</p> <p>Parameters:</p> Name Type Description Default <code>scores</code> <code>DataFrame</code> <p>The scores to save.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to generate the scores.</p> required <code>corpus</code> <code>Corpus</code> <p>The corpus used to generate the scores.</p> required <code>model</code> <code>GenerativeModel | ClassifierModel</code> <p>The model used to generate the scores.</p> required <code>adaptor</code> <code>Adaptor</code> <p>The adaptor used to generate the scores.</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder used to generate the scores.</p> required <code>md5</code> <code>str</code> <p>The md5 hash of the identifier columns.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not set.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>def save(\n    self,\n    *,\n    scores: DataFrame,\n    optimizer: Optimizer,\n    corpus: Corpus,\n    model: GenerativeModel | ClassifierModel,\n    adaptor: Adaptor,\n    embedder: Embedder,\n    md5: str,\n) -&gt; None:\n    \"\"\"\n    Saves the scores to the path.\n    If the root path is not set in the constructor, the scores are not saved.\n\n    Parameters:\n        scores: The scores to save.\n        optimizer: The optimizer used to generate the scores.\n        corpus: The corpus used to generate the scores.\n        model: The model used to generate the scores.\n        adaptor: The adaptor used to generate the scores.\n        embedder: The embedder used to generate the scores.\n        md5: The md5 hash of the identifier columns.\n\n    Raises:\n        ValueError: If the path is not set.\n    \"\"\"\n\n    if self.root is None:\n        LOGGER.warning(\"No path set to save the scores. Skip\")\n        return\n\n    scores = self.with_cols(\n        scores,\n        {\n            columns.OPTIMIZER: optimizer,\n            columns.MODEL: model,\n            columns.ADAPTOR: adaptor,\n            columns.INDEX: corpus.index,\n            columns.STORAGE: corpus.storage,\n            columns.EMBEDDER: embedder,\n            columns.TIME: self._start,\n            columns.MD5: md5,\n        },\n    )\n\n    (self.root / md5).mkdir(exist_ok=True)\n    scores.to_csv(self.root / md5 / f\"{self._start}.csv\", index=False)\n</code></pre>"},{"location":"references/exams/#bocoel.Manager.with_cols","title":"with_cols","text":"<pre><code>with_cols(df: DataFrame, columns: dict[str, Any]) -&gt; DataFrame\n</code></pre> <p>Adds identifier columns to the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to add the columns to.</p> required <code>mappings</code> <p>The columns to add to the DataFrame.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The md5 hash of the identifier columns and the DataFrame with the columns added.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>def with_cols(self, df: DataFrame, columns: dict[str, Any]) -&gt; DataFrame:\n    \"\"\"\n    Adds identifier columns to the DataFrame.\n\n    Parameters:\n        df: The DataFrame to add the columns to.\n        mappings: The columns to add to the DataFrame.\n\n    Returns:\n        The md5 hash of the identifier columns and the DataFrame with the columns added.\n    \"\"\"\n\n    df = df.copy()\n\n    for key, value in columns.items():\n        df[key] = [str(value)] * len(df)\n\n    return df\n</code></pre>"},{"location":"references/exams/#bocoel.Manager._launch","title":"_launch  <code>staticmethod</code>","text":"<pre><code>_launch(\n    optimizer: Optimizer, steps: int | None = None\n) -&gt; Generator[Mapping[int, float], None, None]\n</code></pre> <p>Launches the optimizer as a generator.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>@staticmethod\ndef _launch(\n    optimizer: Optimizer, steps: int | None = None\n) -&gt; Generator[Mapping[int, float], None, None]:\n    \"Launches the optimizer as a generator.\"\n\n    steps_range = range(steps) if steps is not None else itertools.count()\n\n    for _ in ap.alive_it(steps_range, title=\"Running the optimizer\"):\n        # Raises StopIteration (converted to RuntimError per PEP 479) if done.\n        try:\n            results = optimizer.step()\n        except StopIteration:\n            break\n\n        yield results\n</code></pre>"},{"location":"references/exams/#bocoel.Manager.load","title":"load  <code>staticmethod</code>","text":"<pre><code>load(path: str | Path) -&gt; DataFrame\n</code></pre> <p>Loads the scores from the path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to load the scores from.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The loaded scores.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path does not exist or is not a directory.</p> <code>ValueError</code> <p>If no csv files are found in the path.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>@staticmethod\ndef load(path: str | Path) -&gt; DataFrame:\n    \"\"\"\n    Loads the scores from the path.\n\n    Parameters:\n        path: The path to load the scores from.\n\n    Returns:\n        The loaded scores.\n\n    Raises:\n        ValueError: If the path does not exist or is not a directory.\n        ValueError: If no csv files are found in the path.\n    \"\"\"\n\n    # Iterate over all csv files in the path.\n    dfs = [pd.read_csv(csv) for csv in Path(path).rglob(f\"*.csv\")]\n\n    if not dfs:\n        raise ValueError(f\"No csv files found in {path}\")\n\n    return pd.concat(dfs)\n</code></pre>"},{"location":"references/exams/#bocoel.Manager.md5","title":"md5  <code>staticmethod</code>","text":"<pre><code>md5(\n    *,\n    optimizer: Optimizer,\n    embedder: Embedder,\n    corpus: Corpus,\n    model: GenerativeModel | ClassifierModel,\n    adaptor: Adaptor\n) -&gt; str\n</code></pre> <p>Generates an md5 hash from the given data.</p> <p>Parameters:</p> Name Type Description Default <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to generate the scores.</p> required <code>corpus</code> <code>Corpus</code> <p>The corpus used to generate the scores.</p> required <code>model</code> <code>GenerativeModel | ClassifierModel</code> <p>The model used to generate the scores.</p> required <code>adaptor</code> <code>Adaptor</code> <p>The adaptor used to generate the scores.</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder used to generate the scores.</p> required <code>time</code> <p>The time the scores were generated.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The md5 hash of the given data.</p> Source code in <code>src/bocoel/core/exams/managers.py</code> <pre><code>@staticmethod\ndef md5(\n    *,\n    optimizer: Optimizer,\n    embedder: Embedder,\n    corpus: Corpus,\n    model: GenerativeModel | ClassifierModel,\n    adaptor: Adaptor,\n) -&gt; str:\n    \"\"\"\n    Generates an md5 hash from the given data.\n\n    Parameters:\n        optimizer: The optimizer used to generate the scores.\n        corpus: The corpus used to generate the scores.\n        model: The model used to generate the scores.\n        adaptor: The adaptor used to generate the scores.\n        embedder: The embedder used to generate the scores.\n        time: The time the scores were generated.\n\n    Returns:\n        The md5 hash of the given data.\n    \"\"\"\n\n    data = [optimizer, embedder, corpus.index, corpus.storage, model, adaptor]\n\n    return hashlib.md5(\n        str.encode(\" \".join([str(item) for item in data]))\n    ).hexdigest()\n</code></pre>"},{"location":"references/exams/#bocoel.core.exams.columns","title":"bocoel.core.exams.columns","text":"<p>This module contains the columns names used in the manager dataframes, which correspond to the different components and exams of the system.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components","title":"components","text":""},{"location":"references/exams/#bocoel.core.exams.columns.components.TIME","title":"TIME  <code>module-attribute</code>","text":"<pre><code>TIME = 'time'\n</code></pre> <p>Corresponds to the time at which the evaluation was performed.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.INDEX","title":"INDEX  <code>module-attribute</code>","text":"<pre><code>INDEX = 'index'\n</code></pre> <p>Corresponds to the index.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.STORAGE","title":"STORAGE  <code>module-attribute</code>","text":"<pre><code>STORAGE = 'storage'\n</code></pre> <p>Corresponds to the storage.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.EMBEDDER","title":"EMBEDDER  <code>module-attribute</code>","text":"<pre><code>EMBEDDER = 'embedder'\n</code></pre> <p>Corresponds to the embedder.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.OPTIMIZER","title":"OPTIMIZER  <code>module-attribute</code>","text":"<pre><code>OPTIMIZER = 'optimizer'\n</code></pre> <p>Corresponds to the optimizer.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.MODEL","title":"MODEL  <code>module-attribute</code>","text":"<pre><code>MODEL = 'model'\n</code></pre> <p>Corresponds to the model.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.ADAPTOR","title":"ADAPTOR  <code>module-attribute</code>","text":"<pre><code>ADAPTOR = 'adaptor'\n</code></pre> <p>Corresponds to the adaptor.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.components.MD5","title":"MD5  <code>module-attribute</code>","text":"<pre><code>MD5 = 'md5'\n</code></pre> <p>Corresponds to the MD5 hash of the evaluation. This is a hash of most movable components.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams","title":"exams","text":""},{"location":"references/exams/#bocoel.core.exams.columns.exams.ORIGINAL","title":"ORIGINAL  <code>module-attribute</code>","text":"<pre><code>ORIGINAL = 'original'\n</code></pre> <p>Corresponds to the original evaluation. The raw values.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.STEP_IDX","title":"STEP_IDX  <code>module-attribute</code>","text":"<pre><code>STEP_IDX = 'step_idx'\n</code></pre> <p>Corresponds to the step index.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.ACC_MIN","title":"ACC_MIN  <code>module-attribute</code>","text":"<pre><code>ACC_MIN = 'acc_min'\n</code></pre> <p>Corresponds to the minimum accuracy.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.ACC_MAX","title":"ACC_MAX  <code>module-attribute</code>","text":"<pre><code>ACC_MAX = 'acc_max'\n</code></pre> <p>Corresponds to the maximum accuracy.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.ACC_AVG","title":"ACC_AVG  <code>module-attribute</code>","text":"<pre><code>ACC_AVG = 'acc_avg'\n</code></pre> <p>Corresponds to the average accuracy.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.MST_MAX_EDGE_QUERY","title":"MST_MAX_EDGE_QUERY  <code>module-attribute</code>","text":"<pre><code>MST_MAX_EDGE_QUERY = 'mst_max_edge_query'\n</code></pre> <p>Corresponds to the query for the maximum edge of the minimum spanning tree.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.MST_MAX_EDGE_DATA","title":"MST_MAX_EDGE_DATA  <code>module-attribute</code>","text":"<pre><code>MST_MAX_EDGE_DATA = 'mst_max_edge_data'\n</code></pre> <p>Corresponds to the data for the maximum edge of the minimum spanning tree.</p>"},{"location":"references/exams/#bocoel.core.exams.columns.exams.SEGREGATION","title":"SEGREGATION  <code>module-attribute</code>","text":"<pre><code>SEGREGATION = 'segregation'\n</code></pre> <p>Corresponds to the number of unique clusters.</p>"},{"location":"references/factories/","title":"Factories","text":""},{"location":"references/factories/#bocoel.factories.IndexName","title":"bocoel.factories.IndexName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The names of the indices.</p>"},{"location":"references/factories/#bocoel.factories.IndexName.FAISS","title":"FAISS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAISS = 'FAISS'\n</code></pre> <p>Corresponds to <code>FaissIndex</code>.</p>"},{"location":"references/factories/#bocoel.factories.IndexName.HNSWLIB","title":"HNSWLIB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HNSWLIB = 'HNSWLIB'\n</code></pre> <p>Corresponds to <code>HnswlibIndex</code>.</p>"},{"location":"references/factories/#bocoel.factories.IndexName.POLAR","title":"POLAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLAR = 'POLAR'\n</code></pre> <p>Corresponds to <code>PolarIndex</code>.</p>"},{"location":"references/factories/#bocoel.factories.IndexName.WHITENING","title":"WHITENING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WHITENING = 'WHITENING'\n</code></pre> <p>Corresponds to <code>WhiteningIndex</code>.</p>"},{"location":"references/factories/#bocoel.factories.index_class","title":"bocoel.factories.index_class","text":"<pre><code>index_class(name: str | IndexName) -&gt; type[Index]\n</code></pre> <p>Get the index class for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | IndexName</code> <p>The name of the index.</p> required Source code in <code>src/bocoel/factories/indices.py</code> <pre><code>def index_class(name: str | IndexName, /) -&gt; type[Index]:\n    \"\"\"\n    Get the index class for the given name.\n\n    Parameters:\n        name: The name of the index.\n    \"\"\"\n\n    name = IndexName.lookup(name)\n\n    match name:\n        case IndexName.FAISS:\n            return FaissIndex\n        case IndexName.HNSWLIB:\n            return HnswlibIndex\n        case IndexName.POLAR:\n            return PolarIndex\n        case IndexName.WHITENING:\n            return WhiteningIndex\n        case _:\n            raise ValueError(f\"Unknown index name: {name}\")\n</code></pre>"},{"location":"references/factories/#bocoel.factories.StorageName","title":"bocoel.factories.StorageName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The storage names.</p>"},{"location":"references/factories/#bocoel.factories.StorageName.PANDAS","title":"PANDAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PANDAS = 'PANDAS'\n</code></pre> <p>Corresponds to <code>PandasStorage</code>.</p>"},{"location":"references/factories/#bocoel.factories.StorageName.DATASETS","title":"DATASETS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATASETS = 'DATASETS'\n</code></pre> <p>Corresponds to <code>DatasetsStorage</code>.</p>"},{"location":"references/factories/#bocoel.factories.storage","title":"bocoel.factories.storage","text":"<pre><code>storage(\n    storage: str | StorageName,\n    /,\n    *,\n    path: str = \"\",\n    name: str = \"\",\n    split: str = \"\",\n) -&gt; Storage\n</code></pre> <p>Create a single storage.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>str | StorageName</code> <p>The name of the storage.</p> required <code>path</code> <code>str</code> <p>The path to the storage.</p> <code>''</code> <code>name</code> <code>str</code> <p>The name of the storage.</p> <code>''</code> <code>split</code> <code>str</code> <p>The split to use.</p> <code>''</code> <p>Returns:</p> Type Description <code>Storage</code> <p>The storage instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the storage is unknown.</p> Source code in <code>src/bocoel/factories/storages.py</code> <pre><code>@common.correct_kwargs\ndef storage(\n    storage: str | StorageName, /, *, path: str = \"\", name: str = \"\", split: str = \"\"\n) -&gt; Storage:\n    \"\"\"\n    Create a single storage.\n\n    Parameters:\n        storage: The name of the storage.\n        path: The path to the storage.\n        name: The name of the storage.\n        split: The split to use.\n\n    Returns:\n        The storage instance.\n\n    Raises:\n        ValueError: If the storage is unknown.\n    \"\"\"\n\n    storage = StorageName.lookup(storage)\n    match storage:\n        case StorageName.PANDAS:\n            return common.correct_kwargs(PandasStorage.from_jsonl_file)(path)\n        case StorageName.DATASETS:\n            return common.correct_kwargs(DatasetsStorage)(\n                path=path, name=name, split=split\n            )\n        case _:\n            raise ValueError(f\"Unknown storage name {storage}\")\n</code></pre>"},{"location":"references/factories/#bocoel.factories.EmbedderName","title":"bocoel.factories.EmbedderName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The names of the embedders.</p>"},{"location":"references/factories/#bocoel.factories.EmbedderName.SBERT","title":"SBERT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SBERT = 'SBERT'\n</code></pre> <p>Corresponds to <code>SbertEmbedder</code>.</p>"},{"location":"references/factories/#bocoel.factories.EmbedderName.HUGGINGFACE","title":"HUGGINGFACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUGGINGFACE = 'HUGGINGFACE'\n</code></pre> <p>Corresponds to <code>HuggingfaceEmbedder</code>.</p>"},{"location":"references/factories/#bocoel.factories.EmbedderName.HUGGINGFACE_ENSEMBLE","title":"HUGGINGFACE_ENSEMBLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUGGINGFACE_ENSEMBLE = 'HUGGINGFACE_ENSEMBLE'\n</code></pre> <p>Corresponds to <code>EnsembleEmbedder</code> concatenating <code>HuggingfaceEmbedder</code>.</p>"},{"location":"references/factories/#bocoel.factories.embedder","title":"bocoel.factories.embedder","text":"<pre><code>embedder(\n    name: str | EmbedderName,\n    /,\n    *,\n    model_name: str | list[str],\n    device: str = \"auto\",\n    batch_size: int,\n) -&gt; Embedder\n</code></pre> <p>Create an embedder.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | EmbedderName</code> <p>The name of the embedder.</p> required <code>model_name</code> <code>str | list[str]</code> <p>The model name to use.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> <code>'auto'</code> <code>batch_size</code> <code>int</code> <p>The batch size to use.</p> required <p>Returns:</p> Type Description <code>Embedder</code> <p>The embedder instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is unknown.</p> <code>TypeError</code> <p>If the model name is not a string for SBERT or Huggingface, or not a list of strings for HuggingfaceEnsemble.</p> Source code in <code>src/bocoel/factories/embedders.py</code> <pre><code>def embedder(\n    name: str | EmbedderName,\n    /,\n    *,\n    model_name: str | list[str],\n    device: str = \"auto\",\n    batch_size: int,\n) -&gt; Embedder:\n    \"\"\"\n    Create an embedder.\n\n    Parameters:\n        name: The name of the embedder.\n        model_name: The model name to use.\n        device: The device to use.\n        batch_size: The batch size to use.\n\n    Returns:\n        The embedder instance.\n\n    Raises:\n        ValueError: If the name is unknown.\n        TypeError: If the model name is not a string for SBERT or Huggingface,\n            or not a list of strings for HuggingfaceEnsemble.\n    \"\"\"\n\n    match EmbedderName.lookup(name):\n        case EmbedderName.SBERT:\n            if not isinstance(model_name, str):\n                raise TypeError(\n                    \"SbertEmbedder requires a single model name. \"\n                    f\"Got {model_name} instead.\"\n                )\n\n            return common.correct_kwargs(SbertEmbedder)(\n                model_name=model_name,\n                device=common.auto_device(device),\n                batch_size=batch_size,\n            )\n        case EmbedderName.HUGGINGFACE:\n            if not isinstance(model_name, str):\n                raise TypeError(\n                    \"HuggingfaceEmbedder requires a single model name. \"\n                    f\"Got {model_name} instead.\"\n                )\n            return common.correct_kwargs(HuggingfaceEmbedder)(\n                path=model_name,\n                device=common.auto_device(device),\n                batch_size=batch_size,\n            )\n        case EmbedderName.HUGGINGFACE_ENSEMBLE:\n            if not isinstance(model_name, list):\n                raise TypeError(\n                    \"HuggingfaceEnsembleEmbedder requires a list of model names. \"\n                    f\"Got {model_name} instead.\"\n                )\n\n            device_list = common.auto_device_list(device, len(model_name))\n            return common.correct_kwargs(EnsembleEmbedder)(\n                [\n                    HuggingfaceEmbedder(path=model, device=dev, batch_size=batch_size)\n                    for model, dev in zip(model_name, device_list)\n                ]\n            )\n        case _:\n            raise ValueError(f\"Unknown embedder name: {name}\")\n</code></pre>"},{"location":"references/factories/#bocoel.factories.CorpusName","title":"bocoel.factories.CorpusName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The names of the corpus.</p>"},{"location":"references/factories/#bocoel.factories.CorpusName.COMPOSED","title":"COMPOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPOSED = 'COMPOSED'\n</code></pre> <p>Corresponds to <code>ComposedCorpus</code>.</p>"},{"location":"references/factories/#bocoel.factories.corpus","title":"bocoel.factories.corpus","text":"<pre><code>corpus(\n    name: str | CorpusName = CorpusName.COMPOSED,\n    /,\n    *,\n    storage: Storage,\n    embedder: Embedder,\n    keys: Sequence[str],\n    index_name: str | IndexName,\n    **index_kwargs: Any,\n) -&gt; Corpus\n</code></pre> <p>Create a corpus.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | CorpusName</code> <p>The name of the corpus.</p> <code>COMPOSED</code> <code>storage</code> <code>Storage</code> <p>The storage to use.</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to use.</p> required <code>keys</code> <code>Sequence[str]</code> <p>The key to use for the index.</p> required <code>index_name</code> <code>str | IndexName</code> <p>The name of the index backend to use.</p> required <code>**index_kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the index backend.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Corpus</code> <p>The corpus instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is unknown.</p> Source code in <code>src/bocoel/factories/corpora.py</code> <pre><code>def corpus(\n    name: str | CorpusName = CorpusName.COMPOSED,\n    /,\n    *,\n    storage: Storage,\n    embedder: Embedder,\n    keys: Sequence[str],\n    index_name: str | IndexName,\n    **index_kwargs: Any,\n) -&gt; Corpus:\n    \"\"\"\n    Create a corpus.\n\n    Parameters:\n        name: The name of the corpus.\n        storage: The storage to use.\n        embedder: The embedder to use.\n        keys: The key to use for the index.\n        index_name: The name of the index backend to use.\n        **index_kwargs: The keyword arguments to pass to the index backend.\n\n    Returns:\n        The corpus instance.\n\n    Raises:\n        ValueError: If the name is unknown.\n    \"\"\"\n\n    if CorpusName.lookup(name) is not CorpusName.COMPOSED:\n        raise ValueError(f\"Unknown corpus name: {name}\")\n\n    return common.correct_kwargs(ComposedCorpus.index_storage)(\n        storage=storage,\n        embedder=embedder,\n        keys=keys,\n        index_backend=indices.index_class(index_name),\n        **indices.index_set_backends(index_kwargs),\n    )\n</code></pre>"},{"location":"references/factories/#bocoel.factories.adaptor","title":"bocoel.factories.adaptor","text":"<pre><code>adaptor(name: str | AdaptorName, /, **kwargs: Any) -&gt; Adaptor\n</code></pre> <p>Create an adaptor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | AdaptorName</code> <p>The name of the adaptor.</p> required <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the adaptor. See the documentation of the corresponding adaptor for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Adaptor</code> <p>The adaptor instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is unknown.</p> Source code in <code>src/bocoel/factories/adaptors.py</code> <pre><code>def adaptor(name: str | AdaptorName, /, **kwargs: Any) -&gt; Adaptor:\n    \"\"\"\n    Create an adaptor.\n\n    Parameters:\n        name: The name of the adaptor.\n        **kwargs: The keyword arguments to pass to the adaptor.\n            See the documentation of the corresponding adaptor for details.\n\n    Returns:\n        The adaptor instance.\n\n    Raises:\n        ValueError: If the name is unknown.\n    \"\"\"\n\n    name = AdaptorName.lookup(name)\n\n    match name:\n        case AdaptorName.BIGBENCH_MC:\n            return common.correct_kwargs(BigBenchMultipleChoice)(**kwargs)\n        case AdaptorName.BIGBENCH_QA:\n            return common.correct_kwargs(BigBenchQuestionAnswer)(**kwargs)\n        case AdaptorName.SST2:\n            return common.correct_kwargs(Sst2QuestionAnswer)(**kwargs)\n        case AdaptorName.GLUE:\n            return common.correct_kwargs(GlueAdaptor)(**kwargs)\n        case _:\n            raise ValueError(f\"Unknown adaptor name: {name}\")\n</code></pre>"},{"location":"references/factories/#bocoel.factories.AdaptorName","title":"bocoel.factories.AdaptorName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The names of the adaptors.</p>"},{"location":"references/factories/#bocoel.factories.AdaptorName.BIGBENCH_MC","title":"BIGBENCH_MC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGBENCH_MC = 'BIGBENCH_MULTIPLE_CHOICE'\n</code></pre> <p>Corresponds to <code>BigBenchMultipleChoice</code>.</p>"},{"location":"references/factories/#bocoel.factories.AdaptorName.BIGBENCH_QA","title":"BIGBENCH_QA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGBENCH_QA = 'BIGBENCH_QUESTION_ANSWER'\n</code></pre> <p>Corresponds to <code>BigBenchQuestionAnswer</code>.</p>"},{"location":"references/factories/#bocoel.factories.AdaptorName.SST2","title":"SST2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SST2 = 'SST2'\n</code></pre> <p>Corresponds to <code>Sst2QuestionAnswer</code>.</p>"},{"location":"references/factories/#bocoel.factories.AdaptorName.GLUE","title":"GLUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GLUE = 'GLUE'\n</code></pre> <p>Corresponds to <code>GlueAdaptor</code>.</p>"},{"location":"references/factories/#bocoel.factories.GeneratorName","title":"bocoel.factories.GeneratorName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The generator names.</p>"},{"location":"references/factories/#bocoel.factories.GeneratorName.HUGGINGFACE_GENERATIVE","title":"HUGGINGFACE_GENERATIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUGGINGFACE_GENERATIVE = 'HUGGINGFACE_GENERATIVE'\n</code></pre> <p>Corresponds to <code>HuggingfaceGenerativeLM</code>.</p>"},{"location":"references/factories/#bocoel.factories.generative","title":"bocoel.factories.generative","text":"<pre><code>generative(\n    name: str | GeneratorName,\n    /,\n    *,\n    model_path: str,\n    batch_size: int,\n    device: str = \"auto\",\n    add_sep_token: bool = False,\n) -&gt; GenerativeModel\n</code></pre> <p>Create a generative model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | GeneratorName</code> <p>The name of the model.</p> required <code>model_path</code> <code>str</code> <p>The path to the model.</p> required <code>batch_size</code> <code>int</code> <p>The batch size to use.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> <code>'auto'</code> <code>add_sep_token</code> <code>bool</code> <p>Whether to add the sep token.</p> <code>False</code> <p>Returns:</p> Type Description <code>GenerativeModel</code> <p>The generative model instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is unknown.</p> Source code in <code>src/bocoel/factories/lms.py</code> <pre><code>def generative(\n    name: str | GeneratorName,\n    /,\n    *,\n    model_path: str,\n    batch_size: int,\n    device: str = \"auto\",\n    add_sep_token: bool = False,\n) -&gt; GenerativeModel:\n    \"\"\"\n    Create a generative model.\n\n    Parameters:\n        name: The name of the model.\n        model_path: The path to the model.\n        batch_size: The batch size to use.\n        device: The device to use.\n        add_sep_token: Whether to add the sep token.\n\n    Returns:\n        The generative model instance.\n\n    Raises:\n        ValueError: If the name is unknown.\n    \"\"\"\n\n    device = common.auto_device(device)\n\n    match GeneratorName.lookup(name):\n        case GeneratorName.HUGGINGFACE_GENERATIVE:\n            return common.correct_kwargs(HuggingfaceGenerativeLM)(\n                model_path=model_path,\n                batch_size=batch_size,\n                device=device,\n                add_sep_token=add_sep_token,\n            )\n        case _:\n            raise ValueError(f\"Unknown LM name {name}\")\n</code></pre>"},{"location":"references/factories/#bocoel.factories.ClassifierName","title":"bocoel.factories.ClassifierName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The classifier names.</p>"},{"location":"references/factories/#bocoel.factories.ClassifierName.HUGGINGFACE_LOGITS","title":"HUGGINGFACE_LOGITS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUGGINGFACE_LOGITS = 'HUGGINGFACE_LOGITS'\n</code></pre> <p>Corresponds to <code>HuggingfaceLogitsLM</code>.</p>"},{"location":"references/factories/#bocoel.factories.ClassifierName.HUGGINGFACE_SEQUENCE","title":"HUGGINGFACE_SEQUENCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUGGINGFACE_SEQUENCE = 'HUGGINGFACE_SEQUENCE'\n</code></pre> <p>Corresponds to <code>HuggingfaceSequenceLM</code>.</p>"},{"location":"references/factories/#bocoel.factories.classifier","title":"bocoel.factories.classifier","text":"<pre><code>classifier(\n    name: str | ClassifierName,\n    /,\n    *,\n    model_path: str,\n    batch_size: int,\n    choices: Sequence[str],\n    device: str = \"auto\",\n    add_sep_token: bool = False,\n) -&gt; ClassifierModel\n</code></pre> Source code in <code>src/bocoel/factories/lms.py</code> <pre><code>def classifier(\n    name: str | ClassifierName,\n    /,\n    *,\n    model_path: str,\n    batch_size: int,\n    choices: Sequence[str],\n    device: str = \"auto\",\n    add_sep_token: bool = False,\n) -&gt; ClassifierModel:\n    device = common.auto_device(device)\n\n    match ClassifierName.lookup(name):\n        case ClassifierName.HUGGINGFACE_LOGITS:\n            return common.correct_kwargs(HuggingfaceLogitsLM)(\n                model_path=model_path,\n                batch_size=batch_size,\n                device=device,\n                choices=choices,\n                add_sep_token=add_sep_token,\n            )\n        case ClassifierName.HUGGINGFACE_SEQUENCE:\n            return common.correct_kwargs(HuggingfaceSequenceLM)(\n                model_path=model_path,\n                device=device,\n                choices=choices,\n                add_sep_token=add_sep_token,\n            )\n        case _:\n            raise ValueError(f\"Unknown LM name {name}\")\n</code></pre>"},{"location":"references/factories/#bocoel.factories.OptimizerName","title":"bocoel.factories.OptimizerName","text":"<p>             Bases: <code>StrEnum</code></p> <p>The names of the optimizers.</p>"},{"location":"references/factories/#bocoel.factories.OptimizerName.BAYESIAN","title":"BAYESIAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BAYESIAN = 'BAYESIAN'\n</code></pre> <p>Corresponds to <code>AxServiceOptimizer</code>.</p>"},{"location":"references/factories/#bocoel.factories.OptimizerName.KMEANS","title":"KMEANS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KMEANS = 'KMEANS'\n</code></pre> <p>Corresponds to <code>KMeansOptimizer</code>.</p>"},{"location":"references/factories/#bocoel.factories.OptimizerName.KMEDOIDS","title":"KMEDOIDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KMEDOIDS = 'KMEDOIDS'\n</code></pre> <p>Corresponds to <code>KMedoidsOptimizer</code>.</p>"},{"location":"references/factories/#bocoel.factories.OptimizerName.RANDOM","title":"RANDOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RANDOM = 'RANDOM'\n</code></pre> <p>Corresponds to <code>RandomOptimizer</code>.</p>"},{"location":"references/factories/#bocoel.factories.OptimizerName.BRUTE","title":"BRUTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BRUTE = 'BRUTE'\n</code></pre> <p>Corresponds to <code>BruteForceOptimizer</code>.</p>"},{"location":"references/factories/#bocoel.factories.OptimizerName.UNIFORM","title":"UNIFORM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNIFORM = 'UNIFORM'\n</code></pre> <p>Corresponds to <code>UniformOptimizer</code>.</p>"},{"location":"references/factories/#bocoel.factories.optimizer","title":"bocoel.factories.optimizer","text":"<pre><code>optimizer(\n    name: str | OptimizerName,\n    /,\n    *,\n    corpus: Corpus,\n    adaptor: Adaptor,\n    **kwargs: Any,\n) -&gt; Optimizer\n</code></pre> <p>Create an optimizer instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | OptimizerName</code> <p>The name of the optimizer.</p> required <code>corpus</code> <code>Corpus</code> <p>The corpus to optimize.</p> required <code>adaptor</code> <code>Adaptor</code> <p>The adaptor to use.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the optimizer. See the documentation for the specific optimizer for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optimizer</code> <p>The optimizer instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is unknown.</p> Source code in <code>src/bocoel/factories/optim.py</code> <pre><code>def optimizer(\n    name: str | OptimizerName, /, *, corpus: Corpus, adaptor: Adaptor, **kwargs: Any\n) -&gt; Optimizer:\n    \"\"\"\n    Create an optimizer instance.\n\n    Parameters:\n        name: The name of the optimizer.\n        corpus: The corpus to optimize.\n        adaptor: The adaptor to use.\n        **kwargs: Additional keyword arguments to pass to the optimizer.\n            See the documentation for the specific optimizer for details.\n\n    Returns:\n        The optimizer instance.\n\n    Raises:\n        ValueError: If the name is unknown.\n    \"\"\"\n\n    name = OptimizerName.lookup(name)\n\n    klass: type[Optimizer]\n\n    match name:\n        case OptimizerName.BAYESIAN:\n            klass = AxServiceOptimizer\n        case OptimizerName.KMEANS:\n            klass = KMeansOptimizer\n        case OptimizerName.KMEDOIDS:\n            klass = KMedoidsOptimizer\n        case OptimizerName.BRUTE:\n            klass = BruteForceOptimizer\n        case OptimizerName.RANDOM:\n            klass = RandomOptimizer\n        case OptimizerName.UNIFORM:\n            klass = UniformOptimizer\n        case _:\n            raise ValueError(f\"Unknown optimizer name: {name}\")\n\n    corpus_evaluator = CorpusEvaluator(corpus=corpus, adaptor=adaptor)\n    return klass(index_eval=corpus_evaluator, index=corpus.index, **kwargs)\n</code></pre>"},{"location":"references/indices/","title":"Indices","text":""},{"location":"references/indices/#bocoel.Index","title":"bocoel.Index","text":"<pre><code>Index(embeddings: NDArray, distance: str | Distance, **kwargs: Any)\n</code></pre> <p>             Bases: <code>Protocol</code></p> <p>Index is responsible for fast retrieval given a vector query.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __init__(\n    self, embeddings: NDArray, distance: str | Distance, **kwargs: Any\n) -&gt; None:\n    # Included s.t. constructors of Index can be used.\n    ...\n</code></pre>"},{"location":"references/indices/#bocoel.Index.data","title":"data  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>data: NDArray\n</code></pre> <p>The underly data that the index is used for searching.</p> NOTE <p>This has the shape of [n, dims], where dims is the transformed space.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>The data.</p>"},{"location":"references/indices/#bocoel.Index.batch","title":"batch  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>batch: int\n</code></pre> <p>The batch size used for searching.</p> <p>Returns:</p> Type Description <code>int</code> <p>The batch size.</p>"},{"location":"references/indices/#bocoel.Index.boundary","title":"boundary  <code>property</code>","text":"<pre><code>boundary: Boundary\n</code></pre> <p>The boundary of the queries. This is used to check if the query is in range. By default, this is [-1, 1] for all dimensions, since embeddings are normalized.</p> <p>Returns:</p> Type Description <code>Boundary</code> <p>The boundary of the input.</p>"},{"location":"references/indices/#bocoel.Index.distance","title":"distance  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>distance: Distance\n</code></pre> <p>The distance metric used by the index.</p> <p>Returns:</p> Type Description <code>Distance</code> <p>The distance metric.</p>"},{"location":"references/indices/#bocoel.Index.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: int\n</code></pre> <p>The number of dimensions that the query vector should be.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of dimensions.</p>"},{"location":"references/indices/#bocoel.Index.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of items in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    The number of items in the index.\n\n    Returns:\n        The number of items.\n    \"\"\"\n\n    return len(self.data)\n</code></pre>"},{"location":"references/indices/#bocoel.Index.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NDArray\n</code></pre> <p>Get the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The item.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NDArray:\n    \"\"\"\n    Get the item at the given index.\n\n    Parameters:\n        idx: The index of the item.\n\n    Returns:\n        The item.\n    \"\"\"\n\n    return self.data[idx]\n</code></pre>"},{"location":"references/indices/#bocoel.Index.search","title":"search","text":"<pre><code>search(query: ArrayLike, k: int = 1) -&gt; SearchResultBatch\n</code></pre> <p>Calls the search function and performs some checks.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ArrayLike</code> <p>The query vector. Must be of shape <code>[batch, query_dims]</code>.</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to return.</p> <code>1</code> <p>Returns:</p> Type Description <code>SearchResultBatch</code> <p>A <code>SearchResultBatch</code> instance. See <code>SearchResultBatch</code> for details.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def search(self, query: ArrayLike, k: int = 1) -&gt; SearchResultBatch:\n    \"\"\"\n    Calls the search function and performs some checks.\n\n    Parameters:\n        query: The query vector. Must be of shape `[batch, query_dims]`.\n        k: The number of nearest neighbors to return.\n\n    Returns:\n        A `SearchResultBatch` instance. See `SearchResultBatch` for details.\n    \"\"\"\n\n    query = np.array(query)\n\n    if (ndim := query.ndim) != 2:\n        raise ValueError(\n            f\"Expected query to be a 2D vector, got a vector of dim {ndim}.\"\n        )\n\n    if (dim := query.shape[1]) != self.dims:\n        raise ValueError(f\"Expected query to have dimension {self.dims}, got {dim}\")\n\n    if k &lt; 1:\n        raise ValueError(f\"Expected k to be at least 1, got {k}\")\n\n    results: list[InternalResult] = []\n    for idx in range(0, len(query), self.batch):\n        query_batch = query[idx : idx + self.batch]\n        result = self._search(query_batch, k=k)\n        results.append(result)\n\n    indices = np.concatenate([res.indices for res in results], axis=0)\n    distances = np.concatenate([res.distances for res in results], axis=0)\n    vectors = self.data[indices]\n\n    return SearchResultBatch(\n        query=query, vectors=vectors, distances=distances, indices=indices\n    )\n</code></pre>"},{"location":"references/indices/#bocoel.Index._search","title":"_search  <code>abstractmethod</code>","text":"<pre><code>_search(query: NDArray, k: int = 1) -&gt; InternalResult\n</code></pre> <p>Search the index with a given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>NDArray</code> <p>The query vector. Must be of shape [query_dims].</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to return.</p> <code>1</code> <p>Returns:</p> Type Description <code>InternalResult</code> <p>A numpy array of shape [k]. This corresponds to the indices of the nearest neighbors.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>@abc.abstractmethod\ndef _search(self, query: NDArray, k: int = 1) -&gt; InternalResult:\n    \"\"\"\n    Search the index with a given query.\n\n    Parameters:\n        query: The query vector. Must be of shape [query_dims].\n        k: The number of nearest neighbors to return.\n\n    Returns:\n        A numpy array of shape [k].\n            This corresponds to the indices of the nearest neighbors.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/indices/#bocoel.HnswlibIndex","title":"bocoel.HnswlibIndex","text":"<pre><code>HnswlibIndex(\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    normalize: bool = True,\n    threads: int = -1,\n    batch_size: int = 64\n)\n</code></pre> <p>             Bases: <code>Index</code></p> <p>HNSWLIB index. Uses the hnswlib library.</p> <p>Score is calculated slightly differently https://github.com/nmslib/hnswlib#supported-distances</p> <p>Initializes the HNSWLIB index.</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>NDArray</code> <p>The embeddings to index.</p> required <code>distance</code> <code>str | Distance</code> <p>The distance metric to use.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the embeddings.</p> <code>True</code> <code>threads</code> <code>int</code> <p>The number of threads to use.</p> <code>-1</code> <code>batch_size</code> <code>int</code> <p>The batch size to use for searching.</p> <code>64</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the distance is not supported.</p> Source code in <code>src/bocoel/corpora/indices/backend/hnswlib.py</code> <pre><code>def __init__(\n    self,\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    normalize: bool = True,\n    threads: int = -1,\n    batch_size: int = 64,\n) -&gt; None:\n    \"\"\"\n    Initializes the HNSWLIB index.\n\n    Parameters:\n        embeddings: The embeddings to index.\n        distance: The distance metric to use.\n        normalize: Whether to normalize the embeddings.\n        threads: The number of threads to use.\n        batch_size: The batch size to use for searching.\n\n    Raises:\n        ValueError: If the distance is not supported.\n    \"\"\"\n\n    if normalize:\n        embeddings = utils.normalize(embeddings)\n\n    self.__embeddings = embeddings\n\n    # Would raise ValueError if not a valid distance.\n    self._dist = Distance.lookup(distance)\n    self._batch_size = batch_size\n\n    # A public attribute because this can be changed at anytime.\n    self.threads = threads\n\n    self._init_index()\n</code></pre>"},{"location":"references/indices/#bocoel.HnswlibIndex.boundary","title":"boundary  <code>property</code>","text":"<pre><code>boundary: Boundary\n</code></pre> <p>The boundary of the queries. This is used to check if the query is in range. By default, this is [-1, 1] for all dimensions, since embeddings are normalized.</p> <p>Returns:</p> Type Description <code>Boundary</code> <p>The boundary of the input.</p>"},{"location":"references/indices/#bocoel.HnswlibIndex.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: int\n</code></pre> <p>The number of dimensions that the query vector should be.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of dimensions.</p>"},{"location":"references/indices/#bocoel.HnswlibIndex.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of items in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    The number of items in the index.\n\n    Returns:\n        The number of items.\n    \"\"\"\n\n    return len(self.data)\n</code></pre>"},{"location":"references/indices/#bocoel.HnswlibIndex.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NDArray\n</code></pre> <p>Get the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The item.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NDArray:\n    \"\"\"\n    Get the item at the given index.\n\n    Parameters:\n        idx: The index of the item.\n\n    Returns:\n        The item.\n    \"\"\"\n\n    return self.data[idx]\n</code></pre>"},{"location":"references/indices/#bocoel.HnswlibIndex.search","title":"search","text":"<pre><code>search(query: ArrayLike, k: int = 1) -&gt; SearchResultBatch\n</code></pre> <p>Calls the search function and performs some checks.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ArrayLike</code> <p>The query vector. Must be of shape <code>[batch, query_dims]</code>.</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to return.</p> <code>1</code> <p>Returns:</p> Type Description <code>SearchResultBatch</code> <p>A <code>SearchResultBatch</code> instance. See <code>SearchResultBatch</code> for details.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def search(self, query: ArrayLike, k: int = 1) -&gt; SearchResultBatch:\n    \"\"\"\n    Calls the search function and performs some checks.\n\n    Parameters:\n        query: The query vector. Must be of shape `[batch, query_dims]`.\n        k: The number of nearest neighbors to return.\n\n    Returns:\n        A `SearchResultBatch` instance. See `SearchResultBatch` for details.\n    \"\"\"\n\n    query = np.array(query)\n\n    if (ndim := query.ndim) != 2:\n        raise ValueError(\n            f\"Expected query to be a 2D vector, got a vector of dim {ndim}.\"\n        )\n\n    if (dim := query.shape[1]) != self.dims:\n        raise ValueError(f\"Expected query to have dimension {self.dims}, got {dim}\")\n\n    if k &lt; 1:\n        raise ValueError(f\"Expected k to be at least 1, got {k}\")\n\n    results: list[InternalResult] = []\n    for idx in range(0, len(query), self.batch):\n        query_batch = query[idx : idx + self.batch]\n        result = self._search(query_batch, k=k)\n        results.append(result)\n\n    indices = np.concatenate([res.indices for res in results], axis=0)\n    distances = np.concatenate([res.distances for res in results], axis=0)\n    vectors = self.data[indices]\n\n    return SearchResultBatch(\n        query=query, vectors=vectors, distances=distances, indices=indices\n    )\n</code></pre>"},{"location":"references/indices/#bocoel.FaissIndex","title":"bocoel.FaissIndex","text":"<pre><code>FaissIndex(\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    normalize: bool = True,\n    index_string: str,\n    cuda: bool = False,\n    batch_size: int = 64\n)\n</code></pre> <p>             Bases: <code>Index</code></p> <p>Faiss index. Uses the faiss library.</p> <p>Initializes the Faiss index.</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>NDArray</code> <p>The embeddings to index.</p> required <code>distance</code> <code>str | Distance</code> <p>The distance metric to use.</p> required <code>index_string</code> <code>str</code> <p>The index string to use.</p> required <code>cuda</code> <code>bool</code> <p>Whether to use CUDA.</p> <code>False</code> <code>batch_size</code> <code>int</code> <p>The batch size to use for searching.</p> <code>64</code> Source code in <code>src/bocoel/corpora/indices/backend/faiss.py</code> <pre><code>def __init__(\n    self,\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    normalize: bool = True,\n    index_string: str,\n    cuda: bool = False,\n    batch_size: int = 64,\n) -&gt; None:\n    \"\"\"\n    Initializes the Faiss index.\n\n    Parameters:\n        embeddings: The embeddings to index.\n        distance: The distance metric to use.\n        index_string: The index string to use.\n        cuda: Whether to use CUDA.\n        batch_size: The batch size to use for searching.\n    \"\"\"\n\n    if normalize:\n        embeddings = utils.normalize(embeddings)\n\n    self.__embeddings = embeddings\n\n    self._batch_size = batch_size\n    self._dist = Distance.lookup(distance)\n\n    self._index_string = index_string\n    self._init_index(index_string=index_string, cuda=cuda)\n</code></pre>"},{"location":"references/indices/#bocoel.FaissIndex.boundary","title":"boundary  <code>property</code>","text":"<pre><code>boundary: Boundary\n</code></pre> <p>The boundary of the queries. This is used to check if the query is in range. By default, this is [-1, 1] for all dimensions, since embeddings are normalized.</p> <p>Returns:</p> Type Description <code>Boundary</code> <p>The boundary of the input.</p>"},{"location":"references/indices/#bocoel.FaissIndex.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of items in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    The number of items in the index.\n\n    Returns:\n        The number of items.\n    \"\"\"\n\n    return len(self.data)\n</code></pre>"},{"location":"references/indices/#bocoel.FaissIndex.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NDArray\n</code></pre> <p>Get the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The item.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NDArray:\n    \"\"\"\n    Get the item at the given index.\n\n    Parameters:\n        idx: The index of the item.\n\n    Returns:\n        The item.\n    \"\"\"\n\n    return self.data[idx]\n</code></pre>"},{"location":"references/indices/#bocoel.FaissIndex.search","title":"search","text":"<pre><code>search(query: ArrayLike, k: int = 1) -&gt; SearchResultBatch\n</code></pre> <p>Calls the search function and performs some checks.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ArrayLike</code> <p>The query vector. Must be of shape <code>[batch, query_dims]</code>.</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to return.</p> <code>1</code> <p>Returns:</p> Type Description <code>SearchResultBatch</code> <p>A <code>SearchResultBatch</code> instance. See <code>SearchResultBatch</code> for details.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def search(self, query: ArrayLike, k: int = 1) -&gt; SearchResultBatch:\n    \"\"\"\n    Calls the search function and performs some checks.\n\n    Parameters:\n        query: The query vector. Must be of shape `[batch, query_dims]`.\n        k: The number of nearest neighbors to return.\n\n    Returns:\n        A `SearchResultBatch` instance. See `SearchResultBatch` for details.\n    \"\"\"\n\n    query = np.array(query)\n\n    if (ndim := query.ndim) != 2:\n        raise ValueError(\n            f\"Expected query to be a 2D vector, got a vector of dim {ndim}.\"\n        )\n\n    if (dim := query.shape[1]) != self.dims:\n        raise ValueError(f\"Expected query to have dimension {self.dims}, got {dim}\")\n\n    if k &lt; 1:\n        raise ValueError(f\"Expected k to be at least 1, got {k}\")\n\n    results: list[InternalResult] = []\n    for idx in range(0, len(query), self.batch):\n        query_batch = query[idx : idx + self.batch]\n        result = self._search(query_batch, k=k)\n        results.append(result)\n\n    indices = np.concatenate([res.indices for res in results], axis=0)\n    distances = np.concatenate([res.distances for res in results], axis=0)\n    vectors = self.data[indices]\n\n    return SearchResultBatch(\n        query=query, vectors=vectors, distances=distances, indices=indices\n    )\n</code></pre>"},{"location":"references/indices/#bocoel.WhiteningIndex","title":"bocoel.WhiteningIndex","text":"<pre><code>WhiteningIndex(\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    reduced: int,\n    whitening_backend: type[Index],\n    **backend_kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Index</code></p> <p>Whitening index. Whitens the data before indexing. See https://arxiv.org/abs/2103.15316 for more info.</p> <p>Initializes the whitening index.</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>NDArray</code> <p>The embeddings to index.</p> required <code>distance</code> <code>str | Distance</code> <p>The distance metric to use.</p> required <code>reduced</code> <code>int</code> <p>The reduced dimensionality. NOP if larger than embeddings shape.</p> required <code>whitening_backend</code> <code>type[Index]</code> <p>The backend to use for indexing.</p> required <code>**backend_kwargs</code> <code>Any</code> <p>The backend specific keyword arguments.</p> <code>{}</code> Source code in <code>src/bocoel/corpora/indices/whitening.py</code> <pre><code>def __init__(\n    self,\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    reduced: int,\n    whitening_backend: type[Index],\n    **backend_kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initializes the whitening index.\n\n    Parameters:\n        embeddings: The embeddings to index.\n        distance: The distance metric to use.\n        reduced: The reduced dimensionality. NOP if larger than embeddings shape.\n        whitening_backend: The backend to use for indexing.\n        **backend_kwargs: The backend specific keyword arguments.\n    \"\"\"\n\n    # Reduced might be smaller than embeddings.\n    # In such case, no dimensionality reduction is performed.\n    if reduced &gt; embeddings.shape[1]:\n        reduced = embeddings.shape[1]\n        LOGGER.info(\n            \"Reduced dimensionality is larger than embeddings. Using full dimensionality\",\n            reduced=reduced,\n            embeddings=embeddings.shape,\n        )\n\n    white = self.whiten(embeddings, reduced)\n    assert white.shape[1] == reduced, {\n        \"whitened\": white.shape,\n        \"reduced\": reduced,\n    }\n    self._index = whitening_backend(\n        embeddings=white, distance=distance, **backend_kwargs\n    )\n    assert reduced == self._index.dims\n</code></pre>"},{"location":"references/indices/#bocoel.WhiteningIndex.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: int\n</code></pre> <p>The number of dimensions that the query vector should be.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of dimensions.</p>"},{"location":"references/indices/#bocoel.WhiteningIndex.data","title":"data  <code>property</code>","text":"<pre><code>data: NDArray\n</code></pre> <p>Returns the data. This does not necessarily have the same dimensionality as the original transformed embeddings.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>The data.</p>"},{"location":"references/indices/#bocoel.WhiteningIndex.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of items in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    The number of items in the index.\n\n    Returns:\n        The number of items.\n    \"\"\"\n\n    return len(self.data)\n</code></pre>"},{"location":"references/indices/#bocoel.WhiteningIndex.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NDArray\n</code></pre> <p>Get the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The item.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NDArray:\n    \"\"\"\n    Get the item at the given index.\n\n    Parameters:\n        idx: The index of the item.\n\n    Returns:\n        The item.\n    \"\"\"\n\n    return self.data[idx]\n</code></pre>"},{"location":"references/indices/#bocoel.WhiteningIndex.search","title":"search","text":"<pre><code>search(query: ArrayLike, k: int = 1) -&gt; SearchResultBatch\n</code></pre> <p>Calls the search function and performs some checks.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ArrayLike</code> <p>The query vector. Must be of shape <code>[batch, query_dims]</code>.</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to return.</p> <code>1</code> <p>Returns:</p> Type Description <code>SearchResultBatch</code> <p>A <code>SearchResultBatch</code> instance. See <code>SearchResultBatch</code> for details.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def search(self, query: ArrayLike, k: int = 1) -&gt; SearchResultBatch:\n    \"\"\"\n    Calls the search function and performs some checks.\n\n    Parameters:\n        query: The query vector. Must be of shape `[batch, query_dims]`.\n        k: The number of nearest neighbors to return.\n\n    Returns:\n        A `SearchResultBatch` instance. See `SearchResultBatch` for details.\n    \"\"\"\n\n    query = np.array(query)\n\n    if (ndim := query.ndim) != 2:\n        raise ValueError(\n            f\"Expected query to be a 2D vector, got a vector of dim {ndim}.\"\n        )\n\n    if (dim := query.shape[1]) != self.dims:\n        raise ValueError(f\"Expected query to have dimension {self.dims}, got {dim}\")\n\n    if k &lt; 1:\n        raise ValueError(f\"Expected k to be at least 1, got {k}\")\n\n    results: list[InternalResult] = []\n    for idx in range(0, len(query), self.batch):\n        query_batch = query[idx : idx + self.batch]\n        result = self._search(query_batch, k=k)\n        results.append(result)\n\n    indices = np.concatenate([res.indices for res in results], axis=0)\n    distances = np.concatenate([res.distances for res in results], axis=0)\n    vectors = self.data[indices]\n\n    return SearchResultBatch(\n        query=query, vectors=vectors, distances=distances, indices=indices\n    )\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex","title":"bocoel.PolarIndex","text":"<pre><code>PolarIndex(\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    polar_backend: type[Index],\n    **backend_kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Index</code></p> <p>Index that uses N-sphere coordinates as interfaces. See wikipedia linked below for details.</p> <p>Converting the spatial indices into spherical coordinates has the following benefits:</p> <ul> <li>Since the coordinates are normalized, the radius is always 1.</li> <li>The search region is rectangular in spherical coordinates,     ideal for bayesian optimization.</li> </ul> <p>Wikipedia link on N-sphere</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>NDArray</code> <p>The embeddings to index.</p> required <code>distance</code> <code>str | Distance</code> <p>The distance metric to use.</p> required <code>polar_backend</code> <code>type[Index]</code> <p>The backend to use for indexing.</p> required <code>**backend_kwargs</code> <code>Any</code> <p>The backend specific keyword arguments.</p> <code>{}</code> Source code in <code>src/bocoel/corpora/indices/polar.py</code> <pre><code>def __init__(\n    self,\n    embeddings: NDArray,\n    distance: str | Distance,\n    *,\n    polar_backend: type[Index],\n    **backend_kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        embeddings: The embeddings to index.\n        distance: The distance metric to use.\n        polar_backend: The backend to use for indexing.\n        **backend_kwargs: The backend specific keyword arguments.\n    \"\"\"\n\n    embeddings = utils.normalize(embeddings)\n    self._index = polar_backend(\n        embeddings=embeddings,\n        distance=distance,\n        **backend_kwargs,\n    )\n\n    dims = self._index.dims - 1\n\n    self._boundary = self._polar_boundary(dims)\n    self._data = self._polar_coordinates()\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: int\n</code></pre> <p>The number of dimensions that the query vector should be.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of dimensions.</p>"},{"location":"references/indices/#bocoel.PolarIndex.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of items in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    The number of items in the index.\n\n    Returns:\n        The number of items.\n    \"\"\"\n\n    return len(self.data)\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NDArray\n</code></pre> <p>Get the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The item.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NDArray:\n    \"\"\"\n    Get the item at the given index.\n\n    Parameters:\n        idx: The index of the item.\n\n    Returns:\n        The item.\n    \"\"\"\n\n    return self.data[idx]\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex.search","title":"search","text":"<pre><code>search(query: ArrayLike, k: int = 1) -&gt; SearchResultBatch\n</code></pre> <p>Calls the search function and performs some checks.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ArrayLike</code> <p>The query vector. Must be of shape <code>[batch, query_dims]</code>.</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to return.</p> <code>1</code> <p>Returns:</p> Type Description <code>SearchResultBatch</code> <p>A <code>SearchResultBatch</code> instance. See <code>SearchResultBatch</code> for details.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/indices.py</code> <pre><code>def search(self, query: ArrayLike, k: int = 1) -&gt; SearchResultBatch:\n    \"\"\"\n    Calls the search function and performs some checks.\n\n    Parameters:\n        query: The query vector. Must be of shape `[batch, query_dims]`.\n        k: The number of nearest neighbors to return.\n\n    Returns:\n        A `SearchResultBatch` instance. See `SearchResultBatch` for details.\n    \"\"\"\n\n    query = np.array(query)\n\n    if (ndim := query.ndim) != 2:\n        raise ValueError(\n            f\"Expected query to be a 2D vector, got a vector of dim {ndim}.\"\n        )\n\n    if (dim := query.shape[1]) != self.dims:\n        raise ValueError(f\"Expected query to have dimension {self.dims}, got {dim}\")\n\n    if k &lt; 1:\n        raise ValueError(f\"Expected k to be at least 1, got {k}\")\n\n    results: list[InternalResult] = []\n    for idx in range(0, len(query), self.batch):\n        query_batch = query[idx : idx + self.batch]\n        result = self._search(query_batch, k=k)\n        results.append(result)\n\n    indices = np.concatenate([res.indices for res in results], axis=0)\n    distances = np.concatenate([res.distances for res in results], axis=0)\n    vectors = self.data[indices]\n\n    return SearchResultBatch(\n        query=query, vectors=vectors, distances=distances, indices=indices\n    )\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex._polar_boundary","title":"_polar_boundary","text":"<pre><code>_polar_boundary(dims: int) -&gt; Boundary\n</code></pre> <p>The boundary of the queries. For polar coordinate it is [0, pi] for all dimensions except the last one which is [0, 2 * pi].</p> <p>Returns:</p> Type Description <code>Boundary</code> <p>The boundary of the input.</p> Source code in <code>src/bocoel/corpora/indices/polar.py</code> <pre><code>def _polar_boundary(self, dims: int) -&gt; Boundary:\n    \"\"\"\n    The boundary of the queries.\n    For polar coordinate it is [0, pi] for all dimensions\n    except the last one which is [0, 2 * pi].\n\n    Returns:\n        The boundary of the input.\n    \"\"\"\n\n    # See wikipedia linked in the class documentation for details.\n    upper = np.concatenate([[np.pi] * (dims - 1), [2 * np.pi]])\n    lower = np.zeros_like(upper)\n    return Boundary(np.stack([lower, upper], axis=-1))\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex.polar_to_spatial","title":"polar_to_spatial  <code>staticmethod</code>","text":"<pre><code>polar_to_spatial(r: ArrayLike, theta: ArrayLike) -&gt; NDArray\n</code></pre> <p>Convert an N-sphere coordinates to cartesian coordinates. See wikipedia linked in the class documentation for details.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>ArrayLike</code> <p>The radius of the N-sphere. Has the shape [N].</p> required <code>theta</code> <code>ArrayLike</code> <p>The angles of the N-sphere. Hash the shape [N, D].</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The cartesian coordinates of the N-sphere.</p> Source code in <code>src/bocoel/corpora/indices/polar.py</code> <pre><code>@staticmethod\ndef polar_to_spatial(r: ArrayLike, theta: ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Convert an N-sphere coordinates to cartesian coordinates.\n    See wikipedia linked in the class documentation for details.\n\n    Parameters:\n        r: The radius of the N-sphere. Has the shape [N].\n        theta: The angles of the N-sphere. Hash the shape [N, D].\n\n    Returns:\n        The cartesian coordinates of the N-sphere.\n    \"\"\"\n\n    r = np.array(r)\n    theta = np.array(theta)\n\n    if r.ndim != 1:\n        raise ValueError(f\"Expected r to be 1D, got {r.ndim}\")\n\n    if theta.ndim != 2:\n        raise ValueError(f\"Expected theta to be 2D, got {theta.ndim}\")\n\n    if r.shape[0] != theta.shape[0]:\n        raise ValueError(\n            f\"Expected r and theta to have the same length, got {r.shape[0]} and {theta.shape[0]}\"\n        )\n\n    # Add 1 dimension to the front because spherical coordinate's first dimension is r.\n    sin = np.concatenate([np.ones([len(r), 1]), np.sin(theta)], axis=1)\n    sin = np.cumprod(sin, axis=1)\n    cos = np.concatenate([np.cos(theta), np.ones([len(r), 1])], axis=1)\n    return sin * cos * r[:, None]\n</code></pre>"},{"location":"references/indices/#bocoel.PolarIndex.spatial_to_polar","title":"spatial_to_polar  <code>staticmethod</code>","text":"<pre><code>spatial_to_polar(x: ArrayLike) -&gt; tuple[NDArray, NDArray]\n</code></pre> <p>Convert cartesian coordinates to N-sphere coordinates. See wikipedia linked in the class documentation for details.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>The cartesian coordinates. Has the shape [N, D].</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>A tuple. The radius and the angles of the N-sphere.</p> Source code in <code>src/bocoel/corpora/indices/polar.py</code> <pre><code>@staticmethod\ndef spatial_to_polar(x: ArrayLike) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"\n    Convert cartesian coordinates to N-sphere coordinates.\n    See wikipedia linked in the class documentation for details.\n\n    Parameters:\n        x: The cartesian coordinates. Has the shape [N, D].\n\n    Returns:\n        A tuple. The radius and the angles of the N-sphere.\n    \"\"\"\n\n    x = np.array(x)\n\n    if x.ndim != 2:\n        raise ValueError(f\"Expected x to be 2D, got {x.ndim}\")\n\n    # Since the function requires a lot of sum of squares, cache it.\n    x_2 = x[:, 1:] ** 2\n\n    r = np.sqrt(x_2.sum(axis=1))\n    cumsum_back = np.cumsum(x_2[:, ::-1], axis=1)[:, ::-1]\n\n    theta = np.arctan2(np.sqrt(cumsum_back), x[:, 1:])\n    return r, theta\n</code></pre>"},{"location":"references/indices/#bocoel.Boundary","title":"bocoel.Boundary  <code>dataclass</code>","text":"<p>The boundary of embeddings in a corpus. The boundary is defined as a hyperrectangle in the embedding space.</p>"},{"location":"references/indices/#bocoel.Boundary.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: NDArray\n</code></pre> <p>The boundary arrays of the corpus. Must be of shape <code>[dims, 2]</code>, where dims is the number of dimensions. The first column is the lower bound, the second column is the upper bound.</p>"},{"location":"references/indices/#bocoel.Boundary.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: int\n</code></pre> <p>The number of dimensions.</p>"},{"location":"references/indices/#bocoel.Boundary.lower","title":"lower  <code>property</code>","text":"<pre><code>lower: NDArray\n</code></pre> <p>The lower bounds. Must be of shape <code>[dims]</code>.</p>"},{"location":"references/indices/#bocoel.Boundary.upper","title":"upper  <code>property</code>","text":"<pre><code>upper: NDArray\n</code></pre> <p>The upper bounds. Must be of shape <code>[dims]</code>.</p>"},{"location":"references/indices/#bocoel.Boundary.fixed","title":"fixed  <code>classmethod</code>","text":"<pre><code>fixed(lower: float, upper: float, dims: int) -&gt; Self\n</code></pre> <p>Create a fixed boundary for all dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>lower</code> <code>float</code> <p>The lower bound.</p> required <code>upper</code> <code>float</code> <p>The upper bound.</p> required <code>dims</code> <code>int</code> <p>The number of dimensions.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A <code>Boundary</code> instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If lower &gt; upper.</p> Source code in <code>src/bocoel/corpora/indices/interfaces/boundaries.py</code> <pre><code>@classmethod\ndef fixed(cls, lower: float, upper: float, dims: int) -&gt; Self:\n    \"\"\"\n    Create a fixed boundary for all dimensions.\n\n    Parameters:\n        lower: The lower bound.\n        upper: The upper bound.\n        dims: The number of dimensions.\n\n    Returns:\n        A `Boundary` instance.\n\n    Raises:\n        ValueError: If lower &gt; upper.\n    \"\"\"\n\n    if lower &gt; upper:\n        raise ValueError(\"Expected lower &lt;= upper\")\n\n    return cls(bounds=np.array([[lower, upper]] * dims))\n</code></pre>"},{"location":"references/indices/#bocoel.Distance","title":"bocoel.Distance","text":"<p>             Bases: <code>StrEnum</code></p> <p>Distance metrics.</p>"},{"location":"references/indices/#bocoel.Distance.L2","title":"L2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>L2 = 'L2'\n</code></pre> <p>L2 distance. Also known as Euclidean distance.</p>"},{"location":"references/indices/#bocoel.Distance.INNER_PRODUCT","title":"INNER_PRODUCT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INNER_PRODUCT = 'IP'\n</code></pre> <p>Inner product distance. When normalized, this is equivalent to cosine similarity.</p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.results._SearchResult","title":"bocoel.corpora.indices.interfaces.results._SearchResult  <code>dataclass</code>","text":""},{"location":"references/indices/#bocoel.corpora.indices.interfaces.results._SearchResult.query","title":"query  <code>instance-attribute</code>","text":"<pre><code>query: NDArray\n</code></pre> <p>Query vector. If batched, should have shape [batch, dims]. Or else, should have shape [dims].</p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.results._SearchResult.vectors","title":"vectors  <code>instance-attribute</code>","text":"<pre><code>vectors: NDArray\n</code></pre> <p>Nearest neighbors. If batched, should have shape [batch, k, dims]. Or else, should have shape [k, dims].</p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.results._SearchResult.distances","title":"distances  <code>instance-attribute</code>","text":"<pre><code>distances: NDArray\n</code></pre> <p>Calculated distance. If batched, should have shape [batch, k]. Or else, should have shape [k].</p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.results._SearchResult.indices","title":"indices  <code>instance-attribute</code>","text":"<pre><code>indices: NDArray\n</code></pre> <p>Index in the original embeddings. Must be integers. If batched, should have shape [batch, k]. Or else, should have shape [k].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResultBatch","title":"bocoel.corpora.SearchResultBatch  <code>dataclass</code>","text":"<p>             Bases: <code>_SearchResult</code></p> <p>A batched version of search result.</p>"},{"location":"references/indices/#bocoel.corpora.SearchResultBatch.query","title":"query  <code>instance-attribute</code>","text":"<pre><code>query: NDArray\n</code></pre> <p>Query vector. If batched, should have shape [batch, dims]. Or else, should have shape [dims].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResultBatch.vectors","title":"vectors  <code>instance-attribute</code>","text":"<pre><code>vectors: NDArray\n</code></pre> <p>Nearest neighbors. If batched, should have shape [batch, k, dims]. Or else, should have shape [k, dims].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResultBatch.distances","title":"distances  <code>instance-attribute</code>","text":"<pre><code>distances: NDArray\n</code></pre> <p>Calculated distance. If batched, should have shape [batch, k]. Or else, should have shape [k].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResultBatch.indices","title":"indices  <code>instance-attribute</code>","text":"<pre><code>indices: NDArray\n</code></pre> <p>Index in the original embeddings. Must be integers. If batched, should have shape [batch, k]. Or else, should have shape [k].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResult","title":"bocoel.corpora.SearchResult  <code>dataclass</code>","text":"<p>             Bases: <code>_SearchResult</code></p> <p>A non-batched version of search result.</p>"},{"location":"references/indices/#bocoel.corpora.SearchResult.query","title":"query  <code>instance-attribute</code>","text":"<pre><code>query: NDArray\n</code></pre> <p>Query vector. If batched, should have shape [batch, dims]. Or else, should have shape [dims].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResult.vectors","title":"vectors  <code>instance-attribute</code>","text":"<pre><code>vectors: NDArray\n</code></pre> <p>Nearest neighbors. If batched, should have shape [batch, k, dims]. Or else, should have shape [k, dims].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResult.distances","title":"distances  <code>instance-attribute</code>","text":"<pre><code>distances: NDArray\n</code></pre> <p>Calculated distance. If batched, should have shape [batch, k]. Or else, should have shape [k].</p>"},{"location":"references/indices/#bocoel.corpora.SearchResult.indices","title":"indices  <code>instance-attribute</code>","text":"<pre><code>indices: NDArray\n</code></pre> <p>Index in the original embeddings. Must be integers. If batched, should have shape [batch, k]. Or else, should have shape [k].</p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.InternalResult","title":"bocoel.corpora.indices.interfaces.InternalResult","text":"<p>             Bases: <code>NamedTuple</code></p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.InternalResult.distances","title":"distances  <code>instance-attribute</code>","text":"<pre><code>distances: NDArray\n</code></pre> <p>Calculated distance.</p>"},{"location":"references/indices/#bocoel.corpora.indices.interfaces.InternalResult.indices","title":"indices  <code>instance-attribute</code>","text":"<pre><code>indices: NDArray\n</code></pre> <p>Index in the original embeddings. Must be integers.</p>"},{"location":"references/lms/","title":"Language Models","text":""},{"location":"references/lms/#bocoel.GenerativeModel","title":"bocoel.GenerativeModel","text":"<p>             Bases: <code>Protocol</code></p>"},{"location":"references/lms/#bocoel.GenerativeModel.generate","title":"generate  <code>abstractmethod</code>","text":"<pre><code>generate(prompts: Sequence[str]) -&gt; Sequence[str]\n</code></pre> TODO <p>Add logits.</p> <p>Generate a sequence of responses given prompts. The length of the response is the same as the prompt. The response would be a continuation of the prompt, and the prompts would be the prefix of the response.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to generate.</p> required <p>Returns:</p> Type Description <code>Sequence[str]</code> <p>The generated responses. The length must be the same as the prompts.</p> Source code in <code>src/bocoel/models/lms/interfaces/generative.py</code> <pre><code>@abc.abstractmethod\ndef generate(self, prompts: Sequence[str], /) -&gt; Sequence[str]:\n    \"\"\"\n    TODO:\n        Add logits.\n\n    Generate a sequence of responses given prompts.\n    The length of the response is the same as the prompt.\n    The response would be a continuation of the prompt,\n    and the prompts would be the prefix of the response.\n\n    Parameters:\n        prompts: The prompts to generate.\n\n    Returns:\n        The generated responses. The length must be the same as the prompts.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/lms/#bocoel.ClassifierModel","title":"bocoel.ClassifierModel","text":"<p>             Bases: <code>Protocol</code></p>"},{"location":"references/lms/#bocoel.ClassifierModel.choices","title":"choices  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>choices: Sequence[str]\n</code></pre> <p>The choices for this language model.</p> <p>Returns:</p> Type Description <code>Sequence[str]</code> <p>The choices for this language model.</p>"},{"location":"references/lms/#bocoel.ClassifierModel.classify","title":"classify","text":"<pre><code>classify(prompts: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Classify the given prompts.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to classify.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The logits for each prompt and choice.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shape of the logits is not [len(prompts), len(choices)].</p> Source code in <code>src/bocoel/models/lms/interfaces/classifiers.py</code> <pre><code>def classify(self, prompts: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Classify the given prompts.\n\n    Parameters:\n        prompts: The prompts to classify.\n\n    Returns:\n        The logits for each prompt and choice.\n\n    Raises:\n        ValueError: If the shape of the logits is not [len(prompts), len(choices)].\n    \"\"\"\n\n    classified = self._classify(prompts)\n\n    if list(classified.shape) != [len(prompts), len(self.choices)]:\n        raise ValueError(\n            f\"Expected logits to have shape {[len(prompts), len(self.choices)]}, \"\n            f\"but got {classified.shape}\"\n        )\n\n    return classified\n</code></pre>"},{"location":"references/lms/#bocoel.ClassifierModel._classify","title":"_classify  <code>abstractmethod</code>","text":"<pre><code>_classify(prompts: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Generate logits given prompts.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to classify.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The logits for each prompt and choice.</p> Source code in <code>src/bocoel/models/lms/interfaces/classifiers.py</code> <pre><code>@abc.abstractmethod\ndef _classify(self, prompts: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Generate logits given prompts.\n\n    Parameters:\n        prompts: The prompts to classify.\n\n    Returns:\n        The logits for each prompt and choice.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceCausalLM","title":"bocoel.HuggingfaceCausalLM","text":"<pre><code>HuggingfaceCausalLM(\n    model_path: str, batch_size: int, device: str, add_sep_token: bool = False\n)\n</code></pre> <p>The Huggingface implementation of language model. This is a wrapper around the Huggingface library, which would try to pull the model from the huggingface hub.</p> FIXME <p><code>add_sep_token</code> might cause huggingface to bug out with index out of range. Still unclear how this might occur as <code>[SEP]</code> is a special token.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>The path to the model.</p> required <code>batch_size</code> <code>int</code> <p>The batch size to use.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> required <code>add_sep_token</code> <code>bool</code> <p>Whether to add the sep token.</p> <code>False</code> Source code in <code>src/bocoel/models/lms/huggingface/causal.py</code> <pre><code>def __init__(\n    self, model_path: str, batch_size: int, device: str, add_sep_token: bool = False\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        model_path: The path to the model.\n        batch_size: The batch size to use.\n        device: The device to use.\n        add_sep_token: Whether to add the sep token.\n    \"\"\"\n\n    # Optional dependency.\n    from transformers import AutoModelForCausalLM\n\n    self._model_path = model_path\n    self._tokenizer = HuggingfaceTokenizer(\n        model_path=model_path, device=device, add_sep_token=add_sep_token\n    )\n\n    # Model used for generation\n    self._model = AutoModelForCausalLM.from_pretrained(model_path)\n    self._model.pad_token = self._tokenizer.pad_token\n\n    self._batch_size = batch_size\n\n    self.to(device)\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceGenerativeLM","title":"bocoel.HuggingfaceGenerativeLM","text":"<pre><code>HuggingfaceGenerativeLM(\n    model_path: str, batch_size: int, device: str, add_sep_token: bool = False\n)\n</code></pre> <p>             Bases: <code>HuggingfaceCausalLM</code>, <code>GenerativeModel</code></p> <p>The generative model backed by huggingface's transformers library.</p> <p>Since huggingface's tokenizer needs padding to the left to work, padding doesn't guarentee the same positional embeddings, and thus, results. If sameness with generating one by one is desired, batch size should be 1.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>The path to the model.</p> required <code>batch_size</code> <code>int</code> <p>The batch size to use.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> required <code>add_sep_token</code> <code>bool</code> <p>Whether to add the sep token.</p> <code>False</code> Source code in <code>src/bocoel/models/lms/huggingface/generative.py</code> <pre><code>def __init__(\n    self, model_path: str, batch_size: int, device: str, add_sep_token: bool = False\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        model_path: The path to the model.\n        batch_size: The batch size to use.\n        device: The device to use.\n        add_sep_token: Whether to add the sep token.\n    \"\"\"\n\n    super().__init__(\n        model_path=model_path,\n        batch_size=batch_size,\n        device=device,\n        add_sep_token=add_sep_token,\n    )\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceLogitsLM","title":"bocoel.HuggingfaceLogitsLM","text":"<pre><code>HuggingfaceLogitsLM(\n    model_path: str,\n    batch_size: int,\n    device: str,\n    choices: Sequence[str],\n    add_sep_token: bool = False,\n)\n</code></pre> <p>             Bases: <code>HuggingfaceCausalLM</code>, <code>ClassifierModel</code></p> <p>Logits classification model backed by huggingface's transformers library. This means that the model would use the logits of ['1', '2', '3', '4', '5'] as the output, if <code>choices = 5</code>, for the current batch of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>The path to the model.</p> required <code>batch_size</code> <code>int</code> <p>The batch size to use.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> required <code>choices</code> <code>Sequence[str]</code> <p>The choices to classify.</p> required <code>add_sep_token</code> <code>bool</code> <p>Whether to add the sep token.</p> <code>False</code> Source code in <code>src/bocoel/models/lms/huggingface/logits.py</code> <pre><code>def __init__(\n    self,\n    model_path: str,\n    batch_size: int,\n    device: str,\n    choices: Sequence[str],\n    add_sep_token: bool = False,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        model_path: The path to the model.\n        batch_size: The batch size to use.\n        device: The device to use.\n        choices: The choices to classify.\n        add_sep_token: Whether to add the sep token.\n    \"\"\"\n\n    super().__init__(\n        model_path=model_path,\n        batch_size=batch_size,\n        device=device,\n        add_sep_token=add_sep_token,\n    )\n\n    self._choices = choices\n    self._encoded_choices = self._encode_tokens(self._choices)\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceLogitsLM.classify","title":"classify","text":"<pre><code>classify(prompts: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Classify the given prompts.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to classify.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The logits for each prompt and choice.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shape of the logits is not [len(prompts), len(choices)].</p> Source code in <code>src/bocoel/models/lms/interfaces/classifiers.py</code> <pre><code>def classify(self, prompts: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Classify the given prompts.\n\n    Parameters:\n        prompts: The prompts to classify.\n\n    Returns:\n        The logits for each prompt and choice.\n\n    Raises:\n        ValueError: If the shape of the logits is not [len(prompts), len(choices)].\n    \"\"\"\n\n    classified = self._classify(prompts)\n\n    if list(classified.shape) != [len(prompts), len(self.choices)]:\n        raise ValueError(\n            f\"Expected logits to have shape {[len(prompts), len(self.choices)]}, \"\n            f\"but got {classified.shape}\"\n        )\n\n    return classified\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceSequenceLM","title":"bocoel.HuggingfaceSequenceLM","text":"<pre><code>HuggingfaceSequenceLM(\n    model_path: str,\n    device: str,\n    choices: Sequence[str],\n    add_sep_token: bool = False,\n)\n</code></pre> <p>             Bases: <code>ClassifierModel</code></p> <p>The sequence classification model backed by huggingface's transformers library.</p> Source code in <code>src/bocoel/models/lms/huggingface/sequences.py</code> <pre><code>def __init__(\n    self,\n    model_path: str,\n    device: str,\n    choices: Sequence[str],\n    add_sep_token: bool = False,\n) -&gt; None:\n    # Optional dependency\n    from transformers import AutoModelForSequenceClassification\n\n    self._model_path = model_path\n    self._tokenizer = HuggingfaceTokenizer(\n        model_path=model_path, device=device, add_sep_token=add_sep_token\n    )\n\n    self._choices = choices\n\n    classifier = AutoModelForSequenceClassification.from_pretrained(model_path)\n    self._classifier = classifier.to(device)\n    self._classifier.config.pad_token_id = self._tokenizer.pad_token_id\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceSequenceLM.classify","title":"classify","text":"<pre><code>classify(prompts: Sequence[str]) -&gt; NDArray\n</code></pre> <p>Classify the given prompts.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to classify.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The logits for each prompt and choice.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shape of the logits is not [len(prompts), len(choices)].</p> Source code in <code>src/bocoel/models/lms/interfaces/classifiers.py</code> <pre><code>def classify(self, prompts: Sequence[str], /) -&gt; NDArray:\n    \"\"\"\n    Classify the given prompts.\n\n    Parameters:\n        prompts: The prompts to classify.\n\n    Returns:\n        The logits for each prompt and choice.\n\n    Raises:\n        ValueError: If the shape of the logits is not [len(prompts), len(choices)].\n    \"\"\"\n\n    classified = self._classify(prompts)\n\n    if list(classified.shape) != [len(prompts), len(self.choices)]:\n        raise ValueError(\n            f\"Expected logits to have shape {[len(prompts), len(self.choices)]}, \"\n            f\"but got {classified.shape}\"\n        )\n\n    return classified\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceTokenizer","title":"bocoel.HuggingfaceTokenizer","text":"<pre><code>HuggingfaceTokenizer(model_path: str, device: str, add_sep_token: bool)\n</code></pre> <p>A tokenizer for Huggingface models.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>The path to the model.</p> required <code>device</code> <code>str</code> <p>The device to use.</p> required <code>add_sep_token</code> <code>bool</code> <p>Whether to add the sep token.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the transformers library is not installed.</p> Source code in <code>src/bocoel/models/lms/huggingface/tokenizers.py</code> <pre><code>def __init__(self, model_path: str, device: str, add_sep_token: bool) -&gt; None:\n    \"\"\"\n    Parameters:\n        model_path: The path to the model.\n        device: The device to use.\n        add_sep_token: Whether to add the sep token.\n\n    Raises:\n        ImportError: If the transformers library is not installed.\n    \"\"\"\n\n    # Optional dependency.\n    from transformers import AutoTokenizer\n\n    # Initializes the tokenizer and pad to the left for sequence generation.\n    self._tokenizer = AutoTokenizer.from_pretrained(\n        model_path, padding_side=\"left\", truncation_side=\"left\"\n    )\n\n    # Always add the pad token.\n    if (eos := self._tokenizer.eos_token) is not None:\n        self._tokenizer.pad_token = eos\n    else:\n        self._tokenizer.add_special_tokens({\"pad_token\": \"[PAD]\"})\n\n    if add_sep_token:\n        if self._tokenizer.sep_token is None:\n            self._tokenizer.add_special_tokens({\"sep_token\": \"[SEP]\"})\n\n    self._device = device\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceTokenizer.to","title":"to","text":"<pre><code>to(device: str) -&gt; Self\n</code></pre> <p>Move the tokenizer to the given device.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>str</code> <p>The device to move to.</p> required Source code in <code>src/bocoel/models/lms/huggingface/tokenizers.py</code> <pre><code>def to(self, device: str, /) -&gt; Self:\n    \"\"\"\n    Move the tokenizer to the given device.\n\n    Parameters:\n        device: The device to move to.\n    \"\"\"\n    self._device = device\n    return self\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceTokenizer.tokenize","title":"tokenize","text":"<pre><code>tokenize(prompts: Sequence[str], /, max_length: int | None = None)\n</code></pre> <p>Tokenize, pad, truncate, cast to device, and yield the encoded results. Returning <code>BatchEncoding</code> but not marked in the type hint due to optional dependency.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to tokenize.</p> required <p>Returns:</p> Type Description <code>BatchEncoding</code> <p>The tokenized prompts.</p> Source code in <code>src/bocoel/models/lms/huggingface/tokenizers.py</code> <pre><code>def tokenize(self, prompts: Sequence[str], /, max_length: int | None = None):\n    \"\"\"\n    Tokenize, pad, truncate, cast to device, and yield the encoded results.\n    Returning `BatchEncoding` but not marked in the type hint\n    due to optional dependency.\n\n    Parameters:\n        prompts: The prompts to tokenize.\n\n    Returns:\n        (BatchEncoding): The tokenized prompts.\n    \"\"\"\n    if not isinstance(prompts, list):\n        prompts = list(prompts)\n\n    inputs = self._tokenizer(\n        prompts,\n        return_tensors=\"pt\",\n        padding=True,\n        truncation=True,\n        max_length=max_length,\n    )\n    return inputs.to(self.device)\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceTokenizer.encode","title":"encode","text":"<pre><code>encode(\n    prompts: Sequence[str],\n    /,\n    return_tensors: str | None = None,\n    add_special_tokens: bool = True,\n)\n</code></pre> <p>Encode the given prompts.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Sequence[str]</code> <p>The prompts to encode.</p> required <code>return_tensors</code> <code>str | None</code> <p>Whether to return tensors.</p> <code>None</code> <code>add_special_tokens</code> <code>bool</code> <p>Whether to add special tokens.</p> <code>True</code> <p>Returns:</p> Type Description <code>Any</code> <p>The encoded prompts.</p> Source code in <code>src/bocoel/models/lms/huggingface/tokenizers.py</code> <pre><code>def encode(\n    self,\n    prompts: Sequence[str],\n    /,\n    return_tensors: str | None = None,\n    add_special_tokens: bool = True,\n):\n    \"\"\"\n    Encode the given prompts.\n\n    Parameters:\n        prompts: The prompts to encode.\n        return_tensors: Whether to return tensors.\n        add_special_tokens: Whether to add special tokens.\n\n    Returns:\n        (Any): The encoded prompts.\n    \"\"\"\n\n    return self._tokenizer.encode(\n        prompts,\n        return_tensors=return_tensors,\n        add_special_tokens=add_special_tokens,\n    )\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceTokenizer.decode","title":"decode","text":"<pre><code>decode(outputs: Any, /, skip_special_tokens: bool = True) -&gt; str\n</code></pre> <p>Decode the given outputs.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>Any</code> <p>The outputs to decode.</p> required <code>skip_special_tokens</code> <code>bool</code> <p>Whether to skip special tokens.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The decoded outputs.</p> Source code in <code>src/bocoel/models/lms/huggingface/tokenizers.py</code> <pre><code>def decode(self, outputs: Any, /, skip_special_tokens: bool = True) -&gt; str:\n    \"\"\"\n    Decode the given outputs.\n\n    Parameters:\n        outputs: The outputs to decode.\n        skip_special_tokens: Whether to skip special tokens.\n\n    Returns:\n        The decoded outputs.\n    \"\"\"\n\n    return self._tokenizer.decode(outputs, skip_special_tokens=skip_special_tokens)\n</code></pre>"},{"location":"references/lms/#bocoel.HuggingfaceTokenizer.batch_decode","title":"batch_decode","text":"<pre><code>batch_decode(outputs: Any, /, skip_special_tokens: bool = True) -&gt; list[str]\n</code></pre> <p>Batch decode the given outputs.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>Any</code> <p>The outputs to decode.</p> required <code>skip_special_tokens</code> <code>bool</code> <p>Whether to skip special tokens.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The batch decoded outputs.</p> Source code in <code>src/bocoel/models/lms/huggingface/tokenizers.py</code> <pre><code>def batch_decode(\n    self, outputs: Any, /, skip_special_tokens: bool = True\n) -&gt; list[str]:\n    \"\"\"\n    Batch decode the given outputs.\n\n    Parameters:\n        outputs: The outputs to decode.\n        skip_special_tokens: Whether to skip special tokens.\n\n    Returns:\n        The batch decoded outputs.\n    \"\"\"\n\n    return self._tokenizer.batch_decode(\n        outputs, skip_special_tokens=skip_special_tokens\n    )\n</code></pre>"},{"location":"references/optimizers/","title":"Optimizers","text":""},{"location":"references/optimizers/#bocoel.core.optim","title":"bocoel.core.optim","text":"<p>Optimizers is much like optimizers in PyTorch, but for the purpose of optimizing queries and search. Each optimizer would perform a few steps that collectively would guide the search towards the optimal trajectory.</p>"},{"location":"references/optimizers/#bocoel.Optimizer","title":"bocoel.Optimizer","text":"<pre><code>Optimizer(index_eval: IndexEvaluator, index: Index, **kwargs: Any)\n</code></pre> <p>             Bases: <code>Protocol</code></p> <p>The protocol for optimizers. Optimizers are used for optimizing the search space, Find the best exploration sequence for a given task.</p> <p>Parameters:</p> Name Type Description Default <code>index_eval</code> <code>IndexEvaluator</code> <p>The id evaluator. Evalutes the items at the given storage indices.</p> required <code>index</code> <code>Index</code> <p>The index that contains information about the domain.</p> required <code>**kwargs</code> <code>Any</code> <p>The keyword arguments.</p> <code>{}</code> Source code in <code>src/bocoel/core/optim/interfaces/optim.py</code> <pre><code>def __init__(self, index_eval: IndexEvaluator, index: Index, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Parameters:\n        index_eval: The id evaluator. Evalutes the items at the given storage indices.\n        index: The index that contains information about the domain.\n        **kwargs: The keyword arguments.\n    \"\"\"\n\n    # Included s.t. constructors of Index can be used.\n    ...\n</code></pre>"},{"location":"references/optimizers/#bocoel.Optimizer.task","title":"task  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>task: Task\n</code></pre> <p>The task to use for the optimization.</p> <p>Returns:</p> Type Description <code>Task</code> <p>One of <code>Task.EXPLORE</code> or <code>Task.MINIMIZE</code> or <code>Task.MAXIMIZE</code>.</p>"},{"location":"references/optimizers/#bocoel.Optimizer.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step() -&gt; Mapping[int, float]\n</code></pre> <p>Perform a single step of optimization. This is a shortcut into the optimization process. For methods that evaluate the entire search at once, this method would output the slices of the entire search.</p> <p>Returns:</p> Type Description <code>Mapping[int, float]</code> <p>A mapping of storage indices to the corresponding scores.</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If the optimization is complete.</p> Source code in <code>src/bocoel/core/optim/interfaces/optim.py</code> <pre><code>@abc.abstractmethod\ndef step(self) -&gt; Mapping[int, float]:\n    \"\"\"\n    Perform a single step of optimization.\n    This is a shortcut into the optimization process.\n    For methods that evaluate the entire search at once,\n    this method would output the slices of the entire search.\n\n    Returns:\n        A mapping of storage indices to the corresponding scores.\n\n    Raises:\n        StopIteration: If the optimization is complete.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/optimizers/#bocoel.AxServiceOptimizer","title":"bocoel.AxServiceOptimizer","text":"<pre><code>AxServiceOptimizer(\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    sobol_steps: int = 0,\n    device: Device = \"cpu\",\n    workers: int = 1,\n    task: Task = Task.EXPLORE,\n    acqf: str | AcquisitionFunc = AcquisitionFunc.AUTO,\n    surrogate: str | SurrogateModel = SurrogateModel.AUTO,\n    surrogate_kwargs: SurrogateOptions | None = None\n)\n</code></pre> <p>             Bases: <code>Optimizer</code></p> <p>The Ax optimizer that uses the service API. See https://ax.dev/tutorials/gpei_hartmann_service.html</p> <p>Parameters:</p> Name Type Description Default <code>index_eval</code> <code>IndexEvaluator</code> <p>The evaluator to use for the query.</p> required <code>index</code> <code>Index</code> <p>The index to for querying.</p> required <code>sobol_steps</code> <code>int</code> <p>The number of steps to use for the Sobol sequence.</p> <code>0</code> <code>device</code> <code>Device</code> <p>The device to use for the optimization.</p> <code>'cpu'</code> <code>workers</code> <code>int</code> <p>The number of workers to use for the optimization.</p> <code>1</code> <code>task</code> <code>Task</code> <p>The task to use for the optimization.</p> <code>EXPLORE</code> <code>acqf</code> <code>str | AcquisitionFunc</code> <p>The acquisition function to use for the optimization.</p> <code>AUTO</code> <code>surrogate</code> <code>str | SurrogateModel</code> <p>The surrogate model to use for the optimization.</p> <code>AUTO</code> <code>surrogate_kwargs</code> <code>SurrogateOptions | None</code> <p>The keyword arguments to pass to the surrogate model.</p> <code>None</code> Source code in <code>src/bocoel/core/optim/ax/optim.py</code> <pre><code>def __init__(\n    self,\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    sobol_steps: int = 0,\n    device: Device = \"cpu\",\n    workers: int = 1,\n    task: Task = Task.EXPLORE,\n    acqf: str | AcquisitionFunc = AcquisitionFunc.AUTO,\n    surrogate: str | SurrogateModel = SurrogateModel.AUTO,\n    surrogate_kwargs: SurrogateOptions | None = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        index_eval: The evaluator to use for the query.\n        index: The index to for querying.\n        sobol_steps: The number of steps to use for the Sobol sequence.\n        device: The device to use for the optimization.\n        workers: The number of workers to use for the optimization.\n        task: The task to use for the optimization.\n        acqf: The acquisition function to use for the optimization.\n        surrogate: The surrogate model to use for the optimization.\n        surrogate_kwargs: The keyword arguments to pass to the surrogate model.\n    \"\"\"\n\n    silence_ax()\n\n    acqf = AcquisitionFunc.lookup(acqf)\n    task = Task.lookup(task)\n\n    utils.check_acquisition_task_combo(acqf=acqf, task=task)\n\n    self._device = device\n    self._acqf = acqf\n    self._surrogate = SurrogateModel.lookup(surrogate).surrogate(surrogate_kwargs)\n    self._task = task\n\n    self._ax_client = AxClient(generation_strategy=self._gen_strat(sobol_steps))\n    self._create_experiment(index.boundary)\n\n    self._index_eval = index_eval\n    self._index = index\n    self._workers = workers\n    self._terminate = False\n</code></pre>"},{"location":"references/optimizers/#bocoel.Task","title":"bocoel.Task","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"references/optimizers/#bocoel.Task.EXPLORE","title":"EXPLORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPLORE = 'EXPLORE'\n</code></pre>"},{"location":"references/optimizers/#bocoel.Task.MINIMIZE","title":"MINIMIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINIMIZE = 'MINIMIZE'\n</code></pre>"},{"location":"references/optimizers/#bocoel.Task.MAXIMIZE","title":"MAXIMIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAXIMIZE = 'MAXIMIZE'\n</code></pre>"},{"location":"references/optimizers/#bocoel.Task.lookup","title":"lookup  <code>classmethod</code>","text":"<pre><code>lookup(name: str | Self) -&gt; Self\n</code></pre> Source code in <code>src/bocoel/common/enums.py</code> <pre><code>@classmethod\ndef lookup(cls, name: str | Self) -&gt; Self:\n    if isinstance(name, cls):\n        return name\n\n    try:\n        return cls[name]\n    except KeyError:\n        pass\n\n    try:\n        return cls(name)\n    except ValueError:\n        pass\n\n    raise ItemNotFound(f\"Item not found in enum. Must be one of {list(cls)}\")\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc","title":"bocoel.AcquisitionFunc","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.ENTROPY","title":"ENTROPY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENTROPY = 'ENTROPY'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.MES","title":"MES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MES = 'MAX_VALUE_ENTROPY'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.UCB","title":"UCB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UCB = 'UPPER_CONFIDENCE_BOUND'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.QUCB","title":"QUCB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUCB = 'QUASI_UPPER_CONFIDENCE_BOUND'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.EI","title":"EI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EI = 'EXPECTED_IMPROVEMENT'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.QEI","title":"QEI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QEI = 'QUASI_EXPECTED_IMPROVEMENT'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO = 'AUTO'\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.botorch_acqf_class","title":"botorch_acqf_class  <code>property</code>","text":"<pre><code>botorch_acqf_class: type[AcquisitionFunction] | None\n</code></pre>"},{"location":"references/optimizers/#bocoel.AcquisitionFunc.lookup","title":"lookup  <code>classmethod</code>","text":"<pre><code>lookup(name: str | Self) -&gt; Self\n</code></pre> Source code in <code>src/bocoel/common/enums.py</code> <pre><code>@classmethod\ndef lookup(cls, name: str | Self) -&gt; Self:\n    if isinstance(name, cls):\n        return name\n\n    try:\n        return cls[name]\n    except KeyError:\n        pass\n\n    try:\n        return cls(name)\n    except ValueError:\n        pass\n\n    raise ItemNotFound(f\"Item not found in enum. Must be one of {list(cls)}\")\n</code></pre>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateModel","title":"bocoel.core.optim.ax.surrogates.SurrogateModel","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateModel.SAAS","title":"SAAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAAS = 'SAAS'\n</code></pre>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateModel.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO = 'AUTO'\n</code></pre>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateModel.lookup","title":"lookup  <code>classmethod</code>","text":"<pre><code>lookup(name: str | Self) -&gt; Self\n</code></pre> Source code in <code>src/bocoel/common/enums.py</code> <pre><code>@classmethod\ndef lookup(cls, name: str | Self) -&gt; Self:\n    if isinstance(name, cls):\n        return name\n\n    try:\n        return cls[name]\n    except KeyError:\n        pass\n\n    try:\n        return cls(name)\n    except ValueError:\n        pass\n\n    raise ItemNotFound(f\"Item not found in enum. Must be one of {list(cls)}\")\n</code></pre>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateModel.surrogate","title":"surrogate","text":"<pre><code>surrogate(surrogate_options: SurrogateOptions | None) -&gt; Surrogate | None\n</code></pre> Source code in <code>src/bocoel/core/optim/ax/surrogates/supported.py</code> <pre><code>def surrogate(self, surrogate_options: SurrogateOptions | None) -&gt; Surrogate | None:\n    if surrogate_options is None:\n        surrogate_options = {}\n\n    match self:\n        case SurrogateModel.AUTO:\n            return None\n        case SurrogateModel.SAAS:\n            return Surrogate(\n                botorch_model_class=SaasFullyBayesianSingleTaskGP,\n                **surrogate_options,\n            )\n</code></pre>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateOptions","title":"bocoel.core.optim.ax.surrogates.SurrogateOptions","text":"<p>             Bases: <code>TypedDict</code></p>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateOptions.mll_class","title":"mll_class  <code>instance-attribute</code>","text":"<pre><code>mll_class: NotRequired[type[MarginalLogLikelihood]]\n</code></pre>"},{"location":"references/optimizers/#bocoel.core.optim.ax.surrogates.SurrogateOptions.mll_options","title":"mll_options  <code>instance-attribute</code>","text":"<pre><code>mll_options: NotRequired[MLLOptions]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptimizer","title":"bocoel.KMeansOptimizer","text":"<pre><code>KMeansOptimizer(\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    batch_size: int,\n    embeddings: NDArray,\n    model_kwargs: KMeansOptions\n)\n</code></pre> <p>             Bases: <code>ScikitLearnOptimizer</code></p> <p>The KMeans optimizer that uses clustering algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>index_eval</code> <code>IndexEvaluator</code> <p>The evaluator to use on the storage.</p> required <code>index</code> <code>Index</code> <p>The index to use for the query.</p> required <code>batch_size</code> <code>int</code> <p>The number of embeddings to evaluate at once.</p> required <code>embeddings</code> <code>NDArray</code> <p>The embeddings to cluster.</p> required <code>model_kwargs</code> <code>KMeansOptions</code> <p>The keyword arguments to pass to the KMeans model.</p> required Source code in <code>src/bocoel/core/optim/sklearn/kmeans.py</code> <pre><code>def __init__(\n    self,\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    batch_size: int,\n    embeddings: NDArray,\n    model_kwargs: KMeansOptions,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        index_eval: The evaluator to use on the storage.\n        index: The index to use for the query.\n        batch_size: The number of embeddings to evaluate at once.\n        embeddings: The embeddings to cluster.\n        model_kwargs: The keyword arguments to pass to the KMeans model.\n    \"\"\"\n\n    model = KMeans(**model_kwargs)\n\n    super().__init__(\n        index_eval=index_eval,\n        index=index,\n        embeddings=embeddings,\n        model=model,\n        batch_size=batch_size,\n    )\n\n    self._model_kwargs = model_kwargs\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions","title":"bocoel.KMeansOptions","text":"<p>             Bases: <code>TypedDict</code></p>"},{"location":"references/optimizers/#bocoel.KMeansOptions.n_clusters","title":"n_clusters  <code>instance-attribute</code>","text":"<pre><code>n_clusters: int\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions.init","title":"init  <code>instance-attribute</code>","text":"<pre><code>init: NotRequired[Literal['k-means++', 'random']]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions.n_init","title":"n_init  <code>instance-attribute</code>","text":"<pre><code>n_init: NotRequired[int | Literal['auto']]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions.tol","title":"tol  <code>instance-attribute</code>","text":"<pre><code>tol: NotRequired[float]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions.verbose","title":"verbose  <code>instance-attribute</code>","text":"<pre><code>verbose: NotRequired[int]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions.random_state","title":"random_state  <code>instance-attribute</code>","text":"<pre><code>random_state: NotRequired[int]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMeansOptions.algorithm","title":"algorithm  <code>instance-attribute</code>","text":"<pre><code>algorithm: NotRequired[Literal['llyod', 'elkan']]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptimizer","title":"bocoel.KMedoidsOptimizer","text":"<pre><code>KMedoidsOptimizer(\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    batch_size: int,\n    embeddings: NDArray,\n    model_kwargs: KMedoidsOptions\n)\n</code></pre> <p>             Bases: <code>ScikitLearnOptimizer</code></p> <p>The KMedoids optimizer that uses clustering algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>index_eval</code> <code>IndexEvaluator</code> <p>The evaluator to use for the index.</p> required <code>index</code> <code>Index</code> <p>The index to use for the query.</p> required <code>batch_size</code> <code>int</code> <p>The number of embeddings to evaluate at once.</p> required <code>embeddings</code> <code>NDArray</code> <p>The embeddings to cluster.</p> required <code>model_kwargs</code> <code>KMedoidsOptions</code> <p>The keyword arguments to pass to the KMedoids model.</p> required Source code in <code>src/bocoel/core/optim/sklearn/kmedoids.py</code> <pre><code>def __init__(\n    self,\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    batch_size: int,\n    embeddings: NDArray,\n    model_kwargs: KMedoidsOptions,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        index_eval: The evaluator to use for the index.\n        index: The index to use for the query.\n        batch_size: The number of embeddings to evaluate at once.\n        embeddings: The embeddings to cluster.\n        model_kwargs: The keyword arguments to pass to the KMedoids model.\n    \"\"\"\n\n    # Optional dependency.\n    from sklearn_extra.cluster import KMedoids\n\n    model = KMedoids(**model_kwargs)\n\n    super().__init__(\n        index_eval=index_eval,\n        index=index,\n        embeddings=embeddings,\n        model=model,\n        batch_size=batch_size,\n    )\n\n    self._model_kwargs = model_kwargs\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions","title":"bocoel.KMedoidsOptions","text":"<p>             Bases: <code>TypedDict</code></p>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions.n_clusters","title":"n_clusters  <code>instance-attribute</code>","text":"<pre><code>n_clusters: int\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions.metrics","title":"metrics  <code>instance-attribute</code>","text":"<pre><code>metrics: NotRequired[str]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method: NotRequired[Literal['alternate', 'pam']]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions.init","title":"init  <code>instance-attribute</code>","text":"<pre><code>init: NotRequired[Literal['random', 'heuristic', 'kmedoids++', 'build']]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions.max_iter","title":"max_iter  <code>instance-attribute</code>","text":"<pre><code>max_iter: NotRequired[int]\n</code></pre>"},{"location":"references/optimizers/#bocoel.KMedoidsOptions.random_state","title":"random_state  <code>instance-attribute</code>","text":"<pre><code>random_state: NotRequired[int]\n</code></pre>"},{"location":"references/optimizers/#bocoel.RandomOptimizer","title":"bocoel.RandomOptimizer","text":"<pre><code>RandomOptimizer(\n    index_eval: IndexEvaluator, index: Index, *, samples: int, batch_size: int\n)\n</code></pre> <p>             Bases: <code>Optimizer</code></p> <p>The random optimizer that uses random search.</p> <p>Parameters:</p> Name Type Description Default <code>index_eval</code> <code>IndexEvaluator</code> <p>The evaluator to use for the storage.</p> required <code>index</code> <code>Index</code> <p>The index to use for the query.</p> required <code>samples</code> <code>int</code> <p>The number of samples to use for the optimization.</p> required <code>batch_size</code> <code>int</code> <p>The number of samples to evaluate at once.</p> required Source code in <code>src/bocoel/core/optim/random.py</code> <pre><code>def __init__(\n    self,\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    samples: int,\n    batch_size: int,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        index_eval: The evaluator to use for the storage.\n        index: The index to use for the query.\n        samples: The number of samples to use for the optimization.\n        batch_size: The number of samples to evaluate at once.\n    \"\"\"\n\n    LOGGER.info(\"Instantiating RandomOptimizer\", total=len(index), samples=samples)\n\n    self._index_eval = index_eval\n    self._index = index\n    self._generator = iter(BatchedGenerator(self._gen_random(samples), batch_size))\n</code></pre>"},{"location":"references/optimizers/#bocoel.UniformOptimizer","title":"bocoel.UniformOptimizer","text":"<pre><code>UniformOptimizer(\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    grids: Sequence[int],\n    batch_size: int\n)\n</code></pre> <p>             Bases: <code>Optimizer</code></p> <p>The uniform optimizer that uses grid-based search.</p> <p>Parameters:</p> Name Type Description Default <code>index_eval</code> <code>IndexEvaluator</code> <p>The evaluator to use for the storage.</p> required <code>index</code> <code>Index</code> <p>The index to use for the query.</p> required <code>grids</code> <code>Sequence[int]</code> <p>The number of grids to use for the optimization.</p> required <code>batch_size</code> <code>int</code> <p>The number of grids to evaluate at once.</p> required Source code in <code>src/bocoel/core/optim/uniform.py</code> <pre><code>def __init__(\n    self,\n    index_eval: IndexEvaluator,\n    index: Index,\n    *,\n    grids: Sequence[int],\n    batch_size: int,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        index_eval: The evaluator to use for the storage.\n        index: The index to use for the query.\n        grids: The number of grids to use for the optimization.\n        batch_size: The number of grids to evaluate at once.\n    \"\"\"\n\n    LOGGER.info(\"Instantiating UnfiromOptimizer\", grids=grids)\n\n    self._index_eval = index_eval\n    self._index = index\n\n    self._generator = iter(BatchedGenerator(self._gen_locs(grids), batch_size))\n\n    if len(grids) != self._index.dims:\n        raise ValueError(f\"Expected {self._index.dims} strides, got {grids}\")\n</code></pre>"},{"location":"references/optimizers/#bocoel.IndexEvaluator","title":"bocoel.IndexEvaluator","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for evaluating with the indices.</p>"},{"location":"references/optimizers/#bocoel.IndexEvaluator.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(idx: ArrayLike) -&gt; NDArray\n</code></pre> <p>Evaluates the given batched query. The order of the results must be kept in the original order.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>ArrayLike</code> <p>The indices to evaluate. Must be a 1D array.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The indices of the results. Must be in the same order as the query.</p> Source code in <code>src/bocoel/core/optim/interfaces/evals.py</code> <pre><code>@abc.abstractmethod\ndef __call__(self, idx: ArrayLike, /) -&gt; NDArray:\n    \"\"\"\n    Evaluates the given batched query.\n    The order of the results must be kept in the original order.\n\n    Parameters:\n        idx: The indices to evaluate. Must be a 1D array.\n\n    Returns:\n        The indices of the results. Must be in the same order as the query.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/optimizers/#bocoel.QueryEvaluator","title":"bocoel.QueryEvaluator","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for evaluating the query results.</p>"},{"location":"references/optimizers/#bocoel.QueryEvaluator.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(query: ArrayLike) -&gt; OrderedDict[int, float]\n</code></pre> <p>Evaluates the given batched query. The order of the results must be kept in the original order.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ArrayLike</code> <p>The query to evaluate.</p> required <p>Returns:</p> Type Description <code>OrderedDict[int, float]</code> <p>The results of the query. Must be in the same order as the query.</p> Source code in <code>src/bocoel/core/optim/interfaces/evals.py</code> <pre><code>@abc.abstractmethod\ndef __call__(self, query: ArrayLike, /) -&gt; OrderedDict[int, float]:\n    \"\"\"\n    Evaluates the given batched query.\n    The order of the results must be kept in the original order.\n\n    Parameters:\n        query: The query to evaluate.\n\n    Returns:\n        The results of the query. Must be in the same order as the query.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/optimizers/#bocoel.SearchEvaluator","title":"bocoel.SearchEvaluator","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for evaluating the search results.</p>"},{"location":"references/optimizers/#bocoel.SearchEvaluator.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(results: Mapping[int, SearchResult]) -&gt; Mapping[int, float]\n</code></pre> <p>Evaluates the given batched search result. The order of the results must be kept in the original order.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Mapping[int, SearchResult]</code> <p>The results of the search. Mapping from index to search result.</p> required <p>Returns:</p> Type Description <code>Mapping[int, float]</code> <p>The results of the search. Must be in the same order as the query.</p> Source code in <code>src/bocoel/core/optim/interfaces/evals.py</code> <pre><code>@abc.abstractmethod\ndef __call__(self, results: Mapping[int, SearchResult], /) -&gt; Mapping[int, float]:\n    \"\"\"\n    Evaluates the given batched search result.\n    The order of the results must be kept in the original order.\n\n    Parameters:\n        results: The results of the search. Mapping from index to search result.\n\n    Returns:\n        The results of the search. Must be in the same order as the query.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/overview/","title":"Overview","text":"<pre><code>graph TD;\n    embedder --&gt; corpus;\n    index --&gt; corpus;\n    storage --&gt; corpus;\n    corpus --&gt; adaptor;\n    score --&gt; adaptor;\n    adaptor --&gt; optimizer;\n    optimizer --&gt; exams;\n\n    index[&lt;a href='https://rentruewang.github.io/bocoel/references/indices'&gt;Index&lt;/a&gt;]\n    storage[&lt;a href='https://rentruewang.github.io/bocoel/references/storages'&gt;Storage&lt;/a&gt;]\n    embedder[&lt;a href='https://rentruewang.github.io/bocoel/references/embedders'&gt;Embedder&lt;/a&gt;]\n    corpus[&lt;a href='https://rentruewang.github.io/bocoel/references/corpora'&gt;Corpus&lt;/a&gt;]\n    adaptor[&lt;a href='https://rentruewang.github.io/bocoel/references/adaptors'&gt;Adaptor&lt;/a&gt;]\n    score[&lt;a href='https://rentruewang.github.io/bocoel/references/scores'&gt;Score&lt;/a&gt;]\n    optimizer[&lt;a href='https://rentruewang.github.io/bocoel/references/optimizers'&gt;Optimizer&lt;/a&gt;]\n    exams[&lt;a href='https://rentruewang.github.io/bocoel/references/exams'&gt;Exams / Results&lt;/a&gt;]</code></pre>"},{"location":"references/scores/","title":"Scores","text":""},{"location":"references/scores/#bocoel.Score","title":"bocoel.Score","text":"<p>             Bases: <code>Protocol</code></p>"},{"location":"references/scores/#bocoel.Score.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(target: Any, references: list[Any]) -&gt; float\n</code></pre> <p>Evaluate the target with respect to the references.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Any</code> <p>The target to evaluate.</p> required <code>references</code> <code>list[Any]</code> <p>The references to evaluate against.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The score for the target.</p> Source code in <code>src/bocoel/models/scores/interfaces.py</code> <pre><code>@abc.abstractmethod\ndef __call__(self, target: Any, references: list[Any]) -&gt; float:\n    \"\"\"\n    Evaluate the target with respect to the references.\n\n    Parameters:\n        target: The target to evaluate.\n        references: The references to evaluate against.\n\n    Returns:\n        The score for the target.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/scores/#bocoel.NltkBleuScore","title":"bocoel.NltkBleuScore","text":"<p>             Bases: <code>Score</code></p>"},{"location":"references/scores/#bocoel.SacreBleuScore","title":"bocoel.SacreBleuScore","text":"<pre><code>SacreBleuScore()\n</code></pre> <p>             Bases: <code>Score</code></p> Source code in <code>src/bocoel/models/scores/bleu.py</code> <pre><code>def __init__(self) -&gt; None:\n    # Optional dependency.\n    from sacrebleu import BLEU\n\n    self._bleu = BLEU(\n        smooth_method=\"exp\",\n        smooth_value=0.0,\n        force=False,\n        lowercase=False,\n        tokenize=\"intl\",\n    )\n</code></pre>"},{"location":"references/scores/#bocoel.models.scores.rouge._RougeScoreType","title":"bocoel.models.scores.rouge._RougeScoreType  <code>module-attribute</code>","text":"<pre><code>_RougeScoreType = Literal['rouge-1', 'rouge-2', 'rouge-l']\n</code></pre>"},{"location":"references/scores/#bocoel.RougeScore","title":"bocoel.RougeScore","text":"<pre><code>RougeScore(metric: _RougeScoreType)\n</code></pre> <p>             Bases: <code>Score</code></p> Source code in <code>src/bocoel/models/scores/rouge.py</code> <pre><code>def __init__(self, metric: _RougeScoreType) -&gt; None:\n    # Optional dependency.\n    from rouge import Rouge\n\n    self._rouge = Rouge()\n    self._metric = metric\n</code></pre>"},{"location":"references/scores/#bocoel.models.scores.rouge._RougeScore2Type","title":"bocoel.models.scores.rouge._RougeScore2Type  <code>module-attribute</code>","text":"<pre><code>_RougeScore2Type = Literal['rouge1', 'rouge2', 'rougeL']\n</code></pre>"},{"location":"references/scores/#bocoel.RougeScore2","title":"bocoel.RougeScore2","text":"<pre><code>RougeScore2(typ: _RougeScore2Type)\n</code></pre> <p>             Bases: <code>Score</code></p> Source code in <code>src/bocoel/models/scores/rouge.py</code> <pre><code>def __init__(self, typ: _RougeScore2Type) -&gt; None:\n    from rouge_score.rouge_scorer import RougeScorer\n\n    self._scorer = RougeScorer([\"rouge1\", \"rouge2\", \"rougeL\"], use_stemmer=True)\n    self._typ = typ\n</code></pre>"},{"location":"references/scores/#bocoel.OneHotChoiceAccuracy","title":"bocoel.OneHotChoiceAccuracy","text":"<p>             Bases: <code>Score</code></p>"},{"location":"references/scores/#bocoel.MultiChoiceAccuracy","title":"bocoel.MultiChoiceAccuracy","text":"<p>             Bases: <code>Score</code></p>"},{"location":"references/storages/","title":"Storages","text":""},{"location":"references/storages/#bocoel.Storage","title":"bocoel.Storage","text":"<p>             Bases: <code>Protocol</code></p> <p>Storage is responsible for storing the data. This can be thought of as a table.</p>"},{"location":"references/storages/#bocoel.Storage.__len__","title":"__len__  <code>abstractmethod</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the number of rows in the storage.</p> Source code in <code>src/bocoel/corpora/storages/interfaces.py</code> <pre><code>@abc.abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of rows in the storage.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/storages/#bocoel.Storage._getitem","title":"_getitem  <code>abstractmethod</code>","text":"<pre><code>_getitem(idx: int) -&gt; Mapping[str, Any]\n</code></pre> <p>Returns the row at the given index.</p> Source code in <code>src/bocoel/corpora/storages/interfaces.py</code> <pre><code>@abc.abstractmethod\ndef _getitem(self, idx: int) -&gt; Mapping[str, Any]:\n    \"\"\"\n    Returns the row at the given index.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"references/storages/#bocoel.PandasStorage","title":"bocoel.PandasStorage","text":"<pre><code>PandasStorage(df: DataFrame)\n</code></pre> <p>             Bases: <code>Storage</code></p> <p>Storage for pandas DataFrame. Since pandas DataFrames are in-memory, this storage is fast, but might be memory inefficient and require a lot of RAM.</p> Source code in <code>src/bocoel/corpora/storages/pandas.py</code> <pre><code>def __init__(self, df: DataFrame, /) -&gt; None:\n    self._df = df\n</code></pre>"},{"location":"references/storages/#bocoel.PandasStorage.from_jsonl_file","title":"from_jsonl_file  <code>classmethod</code>","text":"<pre><code>from_jsonl_file(path: str | Path) -&gt; Self\n</code></pre> <p>Load data from a JSONL file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the file.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A <code>PandasStorage</code> instance.</p> Source code in <code>src/bocoel/corpora/storages/pandas.py</code> <pre><code>@classmethod\ndef from_jsonl_file(cls, path: str | Path, /) -&gt; Self:\n    \"\"\"\n    Load data from a JSONL file.\n\n    Parameters:\n        path: The path to the file.\n\n    Returns:\n        A `PandasStorage` instance.\n    \"\"\"\n\n    path = Path(path)\n\n    if not path.exists():\n        raise FileNotFoundError(path)\n\n    if not path.is_file():\n        raise ValueError(f\"Cannot open file: {path}\")\n\n    with open(path) as f:\n        lines = map(lambda s: s.strip(\"\\n\"), f.readlines())\n\n    data = [json.loads(line) for line in lines]\n    return cls.from_jsonl(data)\n</code></pre>"},{"location":"references/storages/#bocoel.PandasStorage.from_jsonl","title":"from_jsonl  <code>classmethod</code>","text":"<pre><code>from_jsonl(data: Sequence[Mapping[str, str]]) -&gt; Self\n</code></pre> <p>Load data from a JSONL object or a list of JSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[Mapping[str, str]]</code> <p>The JSONL object or list of JSON.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A <code>PandasStorage</code> instance.</p> Source code in <code>src/bocoel/corpora/storages/pandas.py</code> <pre><code>@classmethod\ndef from_jsonl(cls, data: Sequence[Mapping[str, str]], /) -&gt; Self:\n    \"\"\"\n    Load data from a JSONL object or a list of JSON.\n\n    Parameters:\n        data: The JSONL object or list of JSON.\n\n    Returns:\n        A `PandasStorage` instance.\n    \"\"\"\n\n    df = DataFrame.from_records(data)\n    return cls(df)\n</code></pre>"},{"location":"references/storages/#bocoel.DatasetsStorage","title":"bocoel.DatasetsStorage","text":"<pre><code>DatasetsStorage(path: str, name: str | None = None, split: str | None = None)\n</code></pre> <p>             Bases: <code>Storage</code></p> <p>Storage for datasets from HuggingFace Datasets library. Datasets are loaded on disk, so they might be slow(er) to load, but are more memory efficient.</p> Source code in <code>src/bocoel/corpora/storages/datasets.py</code> <pre><code>def __init__(\n    self, path: str, name: str | None = None, split: str | None = None\n) -&gt; None:\n    # Optional dependency.\n    import datasets\n    from datasets import DatasetDict\n\n    self._path = path\n    self._name = name\n    self._split = split\n\n    ds = datasets.load_dataset(path=path, name=name, trust_remote_code=True)\n\n    if split:\n        if not isinstance(ds, DatasetDict):\n            raise ValueError(\"Split is not supported for this dataset\")\n\n        ds = ds[split]\n\n    self._dataset = ds\n</code></pre>"},{"location":"references/storages/#bocoel.ConcatStorage","title":"bocoel.ConcatStorage","text":"<pre><code>ConcatStorage(storages: Sequence[Storage])\n</code></pre> <p>             Bases: <code>Storage</code></p> <p>Storage that concatenates multiple storages together. Concatenation is done on the first dimension. The resulting storage is read-only and has length equal to the sum of the lengths of the storages.</p> Source code in <code>src/bocoel/corpora/storages/concat.py</code> <pre><code>def __init__(self, storages: Sequence[Storage], /) -&gt; None:\n    if len(storages) &lt; 1:\n        raise ValueError(\"At least one storage is required\")\n\n    diff_keys = set(frozenset(store.keys()) for store in storages)\n    if len(diff_keys) &gt; 1:\n        raise ValueError(\"Keys are not equal\")\n\n    # Unpack the only key in `diff_keys`.\n    (self._keys,) = diff_keys\n    self._storages = tuple(storages)\n\n    LOGGER.info(\"Concat storage created\", storages=storages, keys=diff_keys)\n\n    storage_lengths = [len(store) for store in self._storages]\n    self._prefix_sum = np.cumsum(storage_lengths).tolist()\n    self._length = sum(storage_lengths)\n</code></pre>"}]}